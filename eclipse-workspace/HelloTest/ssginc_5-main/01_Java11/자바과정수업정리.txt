회원가입
1. 구글
2. github
3. 오라클
   www.oracle.com


JDK 다운로드
java.oracle.com
(https://www.oracle.com/java/technologies/)


java 개발 환경 3가지 ( 기준: 디바이스:장치)

1) Java SE ( Java Standard Edition)
   - 일반 PC
   - Java 기술
   - JDK 설치함으로 구축 가능

2) Java EE ( Java Enterprise Edition)
   - 웹서버 ( Tomcat 9 )
    예> 웹 페이지 개발
   - 서블릿,JSP
   - Tomcat 설치함으로 구축 가능

3) Java ME ( Java Micro Edition)
   - 휴대용 장치
    

JDK(Java Development Kit) 설치
기본설치폴더(JDK홈디렉터리):
C:\Program Files\Java\jdk-11

환경변수 설정
시작오른쪽클릭> 시스템 > 고급 시스템 설정 > 환경변수 > 시스템 변수
# JAVA_HOME용도: JDK홈디렉터리 지정
JAVA_HOME=C:\Program Files\Java\jdk-11

# path용도: 명령어 경로 지정
javac.exe  java.exe 
PATH=C:\Program Files\Java\jdk-11;값2;값3


자바에서 사용되는 압축 형식 3가지
1) jar
  - *.class 파일들이 압축된 형식
  예> *.jar

2) war
  - 서블릿/jsp로 만든 웹 어플리케이션 압축된 형식
  예> *.war
 
3) ear
  - jar + war ===> ear로 압축
   예> *.ear


eclipse 개발 도구 ( IDE 툴 )
- 인텔리제이
  www.jetbrains.com
- VSC

www.eclipse.org

download > Download Packages
주의할점 2가지
1) JDK 버전 확인
2) SE 환경 개발?
     - 비웹개발
     Eclipse IDE for Java Developers

   EE 환경 개발?
     - 웹개발
     Eclipse IDE for Enterprise Java and Web Developers

eclipse 설치후 설정

window > preference > 
general > workspace 
> text file encoding 값을 utf-8로 설정.
==> utf-8로 설정해야 한글사용이 가능

window > preference > 
general > Appearance > Colors and Fonts 
> Basic  > Text Font
==> 글꼴설정

window > preference > Java
> Installed JREs

==> eclipse에 내장된 openjdk 대신에
   우리가 설치한 jdk11 사용하도록 변경하자.
###########################################
프로젝트 생성
File > New  > Java Project 선택 

Project Name 지정,
JRE는 JavaSE-11 설정,
Module는 체크 해제하기.

#############################
API의 메뉴얼 제공: API문서 ( API documentation)
https://docs.oracle.com/en/java/javase/11/docs/api/java.base/module-summary.html

#######################
소스파일 작성 ( *.java )

1) 클래스 이름지정 방법
   - 반드시 첫글자는 영문자 또는 _ 또는 $ 만 가능
     이후에 숫자지정 가능.

   - 대소문자 구별

   - 클래스는 첫글자는 반드시 대문자로 지정 ( 관례 )

   - 특수문자는 2개만 가능 ( _, $ )

   - 단어간 공백문자 불가


2) public static  void main( String [] args ) 필수
 ==> 반드시 위 코드 형식으로 지정해야 된다.
 ==> main 메서드라고 부른다.
 ==> 실행하기 위한 시작점(starting point ) 역할이다.

# 생성된 소스
public class Hello {

	public static void main(String[] args) {

	}
}

==> 클래스명(Hello)과 파일명(Hello.java)이 일치해야 된다.
==> 대소문자 구별
==> 클래스 갯수는 3개 
     Hello: 개발자가 만든 클래스
     String: API
     System: API


==> Hello.java 소스파일 작성
        |     컴파일, 컴파일러( javac.exe ), eclipse가 자동으로 해줌.
    Hello.class (byte code, package explore에서는 안보임. navigator에서 보임 )
        |     실행, 인터프리터 ( java.exe )
       결과   ( 콘솔(console)에 결과값이 출력됨 )	    



######################################################
이클립스 단축키
1. 한줄 삭제
    ctrl + d

2. 줄 바꿈
    alt + 화살표키

3. 한줄 복사
   ctrl + alt + 화살표키

4. 명령어 취소
   ctrl + z

5. 파일저장
   ctrl + s

6. 콘솔 출력
   sysout하고 ctrl + spacebar

7. 한줄 주석
   //  , ctrl + / ( 토글 )

8. 여러줄 주석
   /*
       , ctrl + shift +  /
   */

######################################################
식별자 ( identifier )
1. 개념:
    자바소스의 단어 의미

2. 문법
   - 첫글자는 반드시 영문자 또는 특수문자( _, $)
     이후에 숫자지정 가능
   - 대소문자 구별함.
   - 한글지정 가능. (권장안함)

3. 대상 3가지

  1) 클래스
     - 첫글자는 반드시 대문자
     - 권장은 명사형 

  2) 변수
     - 소문자
     - 권장은 명사형

  3) 메서드
     - 소문자
     - 권장은 동사형

4. 식별자 종류 2가지 ( 기준은 주체 )

  가. API
     - 이름이 정해져 있음 ( 예약어, 키워드 )
     - 시스템 정의 식별자
     예> String, System, static, void, public, class
         println, interface, abstract, protected, private,
	 final, transient, default, switch, if, for,..........

  나. 개발자(사용자)
     - 사용자 정의 식별자
     예> args, Hello
     - 반드시 예약어는 제외하고 지정해야 된다. (***********)

==> 나머지 연산자(operator)와 값(데이터,리터럴:literal)으로 구성됨.
   리터럴 형식
   :  "홍길동"
      '남'
      35
      true
      183.45


  ##############################
  () : 소괄호
  {} : 중괄호
  [] : 대괄호
  #########################################################
자바의 데이터 종류 ( 데이터형, data type ) ===> 무조건 외우기
==> 자바언어가 인식 가능한 데이터 종류가 무엇인지 살펴보자.

  가. 기본형 데이터형 ( Primitive Data Type: PDT )
  
      - 수치형 --- 정수 :   byte (  1byte )
                         short ( 2byte )
			 int   ( 4byte ) : 기본
			 long  ( 8byte )
                   - 10진수, 2진수, 8진수, 16진수 모두 사용 가능
                    예>  10진수: 100, -30, 0
                        2진수: 0|1 이용 ( 0b값 )
		             0b1, 0b0
                        8진수: 0~7 이용 ( 0값 )
			      01, 02,...07
                        16진수: 0~9, A,B,C,D,E,F 이용 ( 0x값)
			      0x0, 0x1,..... 0xF
			       

             ---- 실수 :  float ( 4byte )
	                 double ( 8byte ) : 기본
                         - 소수점이용, 지수표현 가능
		 예>  3.14 ( 3.14D, 3.14d ) ===> double로 처리됨

			   3.14F ( 3.14f)  ====> float로 처리됨


      - 문자형 -- char ( 2byte, 캐릭터라고 읽음 )
                   -자바는 전세계의 모든 글자 표현 가능 (한글포함)
                   -이스케이프 문자(escape) 지정 가능
		     예> \t ( tab 클릭효과 얻음) 
		        \n  ( enter 효과 얻음 )
			\"  ( " 출력 )
			\'  ( ' 출력 )
			\\  ( \ 출력 )

	           - 단 하나의 문자 표현식에  사용됨.
		     반드시 '' (홑따옴표)로 감싸야 된다.
		     예>  '남',  '여' ,  'A', 'B'
                  
		  * 문자열은 참조형이다.
                   ==> 문자열은 문자가 여러개
		   ==> 반드시 "" (쌍따옴표)로 감싸야 된다.
		   예> "홍길동", "서울"
		   ==> String 클래스 타입으로 관리됨
		   
      - 논리형 : boolean ( 1byte, 불린 라고 읽음 )
                 - 참/거짓 표현
		   참은 true 표현되고
		   거짓은 false(기본) 표현됨.

  ====> 기본형 데이터 갯수는 8개이다.

  나. 참조형 데이터형 ( Reference Data Type: RDT )
     - 기본형 8개 제외한 나머지가 모두 참조형이다.
     - 대표적으로 클래스, 인터페이스, 배열이다. (****************)
############################################################################
###### 참고할만한 사이트 소개 ##############################################
############################################################################
# 자바 소개 및 특징
https://velog.io/@kojam9041/Java-%EC%9E%90%EB%B0%94-%EC%86%8C%EA%B0%9C-%EB%B0%8F-%ED%8A%B9%EC%A7%95
https://s-bug.tistory.com/57

# 진법 관련 짧은 동영상 
2진수, 8진수, 10진수, 16진수 변환 공부 하실 때 참고
https://www.youtube.com/watch?v=y26oXFInsoI
https://www.youtube.com/shorts/WJo3bZlbHwg
https://www.youtube.com/shorts/dTT_cQrIQJk
https://www.youtube.com/shorts/JonWf0occWw
https://www.youtube.com/shorts/GyOZc9lY_BM
https://www.youtube.com/shorts/lm3Z4ALBHXY
https://www.youtube.com/shorts/FQGLS10uYOk
https://www.youtube.com/shorts/AY5CECThfZ0

# 자바 데이터 타입, 변수, 리터럴 
https://catsbi.oopy.io/6541026f-1e19-4117-8fef-aea145e4fc1b
############################################################################
############################################################################


Hello.java ( 소스파일, 영단어로 구성, 자바인식 불가 )
  |
  |  <=== 자바가 인식가능한 코드로 변경해야 된다.
  |       컴파일 한다고 한다.
  |
Hello.class (byte code, 자바인식이 가능)
##############################################################
1일차 리뷰

1. 자바 3가지 환경
  - Java SE: 기본개발 환경, JDK 설치(2개의 환경변수: JAVA_HOME, PATH )
  - Java EE: 웹 개발 환경 ( 서블릿/jsp ), Tomcat설치
  - Java ME: 모바일 환경

2. 자바 특징
  - 플랫폼(OS)에 독립적==> 생성된 class 파일을 어떤 OS에서도 그냥 실행이 가능하다.
  - 객체지향 프로그래밍(Object Oriented Programming: OOP )

3. 자바 프로그램 개발 순서

   1) 소스작성 ( Hello.java )
      - 개발자가 이해할 수 있는 영단어 코드로 구성
   
   2) 컴파일 단계 ( javac.exe 컴파일러 이용 )
       Hello.java ----------> Hello.class ( bytecode )
      
      문법: javac  Hello.java

   3) 실행 단계 ( java.exe 인터프리터 이용 )
      Hello.class ----------------> 결과값 출력

      문법: java  Hello

4. JVM ( Java Virtual Machine)
  - 역할: bytecode인 class 실행시킴
  - JDK설치하면 JVM이 구축됨
  - S/W이지만 H/W 특징을 가짐 ( 다양한 메모리 포함 )
    주요 메모리: stack, heap, method area

5. 자바에서 사용 가능한 데이터 종류 ( ***************** )

   가. 기본형 데이터 ( 데이터종류, data type )
      - Primitive Data Type: PDT
      - 종류:
               수치형  - 정수형 : byte  (1byte)
	                       short (2byte)
			       int   (4byte): 기본
			       long  (8byte)
			      
			      정수값(리터럴)표현: 10진수, 2진수(0|1), 8진수(0~7), 
			                      16진수(0~9,A,B,C,D,E,F) 모두 사용 가능
                                         예>   10    0b값   0값   0x값
			      만약에 100 정수를 쓰면 기본인 int로 처리가  된다. 	
			      long으로 처리하고 싶으면 100L 지정한다.
					 
	                실수형 : float (4byte) 
                               double (8byte): 기본
                              실수값(리터럴)표현: 소수점이용, 지수표현 가능
			           예>  31.4, 31.4D   ===> double 처리
				       31.4F  ==> float 처리


	       문자형          : char(2byte)
                               -문자형(리터럴)표현: 반드시 '' 사용
			        예> 'A', '남'
                               - escape 문자 ( \t, \n, \\, \', \" )
			       - 전세계의 모든 문자 표현 가능

	       논리형          : boolean (1byte)
                                논리형(리터럴)표현:   true, false


   나. 참조형 데이터 
      - Reference Data Type: RDT
      - 기본형 8개 제외한 나머지 모두
       대표적: 클래스, 인터페이스, 배열
##############################################################################
2일차

1. 정수에서 long 타입으로 사용할 때는 다음과 같이 정수값L 지정한다.
  예> 300L

2. 기본형 8개에 해당되는 클래스 8개를 제공한다.

 기본형          참조형(클래스) ==> wrapper 클래스라고 부른다.
 ----------------------------
 byte		Byte
 short		Short
 int		Integer
 long		Long

 float		Float
 double		Double

 char		Character
 boolean        Boolean


#################################################
3. 변수 ( variable )

  1) 용도
    - 데이터 저장 ( 기본형 데이터 및 참조형 데이터 저장용도 )
    - 언제든지 값이 변경될 수 있음.

  2)사용방법 3단계
    (1) 변수선언
        - 데이터가 저장된 영역 확보 작업 ( 메모리에 저장되고 메모리 위치에 해당되는 이름 지정)
	- 문법:

	    데이터타입 변수명;
         예>  int num;      // int 때문에 4byte 영역확보
	     String name;  // String 참조형이기 때문에 4byte 영역확보

    (2) 변수초기화
        - 생성된 변수에 처음 값을 저장하는 작업
        - 문법:
	     변수명=값;

         예>  num = 19;
	     name = "홍길동";

    (3) 변수 사용
       System.out.println(num);  // 19
       System.out.println(name);


     (4) 변수값 변경
        num=29;
        System.out.println(num);  // 29


4. 기본형 변수 vs 참조형 변수

  1) 기본형 변수
    - 기본형 데이터를 저장하는 변수
    예> 
        int num;   // 실제값이 저장
	num = 20;
    
    ==> num 변수안에 20이 저장됨.

  2) 참조형 변수
    - 참조형 데이터를 저장하는 변수
   
   예>
       String name;  // 주소값이 저장
       name ="홍길동";

   ==> name 변수 안에 "홍길동"이 저장된 주소값이 저장됨.

5. 변수 종류 ( **************************)
  - 변수 선언 위치와 용도에 따른 분류

  가. 로컬 변수 ( local variable )
      - 메서드안에서 선언
      - 생성시점: 메서드 호출시 변수생성됨 
        제거시점: 메서드 호출후 작업이 모두 끝났을 때
      - 생성횟수: 메서드 호출할때마다 매번 생성되고 
                메서드 작업이 끝나면 매번 삭제됨. ( 일시적으로 사용할 목적으로 주로 사용됨 )
      - 저장메모리: stack 메모리
      - 선언만하고 초기화하지 않으면 자동초기화 안됨.
        반드시 사용전에 초기화해야 된다. (******************)
  나. 인스턴스 변수 ( instance variable )
      - 메서드 밖에서 선언
      - 생성시점: 클래스 객체 생성(new 키워드 이용)시 변수생성됨 
        제거시점: 클래스 객체가 제거될 때 변수가 삭제됨.
          ==> 개발자가 클래스를 사용하기 위해서 new 이용한다. ( 클래스 영역 확보 )
	      사용된 클래스 영역을 제거는 개발자가 하지 않고 자바가 자동으로 제거해준다.
	      제거해주는 프로세스는 GC ( Garbage Collector)가 해준다.
	  ==> C 언어는 영역 확보 및 제거를 개발자가 모두 직접 해야된다.
      - 생성횟수: new 할때마다 매번 생성.
      - 저장메모리: heap 메모리
      - 선언만하고 초기화하지 않으면 자동으로 기본값으로 초기화된다.
        기본형:
	    정수: 0
	    실수: 0.0
	    문자: \u0000
	    논리: false
	참조형: null
  다. 클래스 변수 ( class variable, static variable)
      - 메서드 밖에서 선언 + static 키워드 추가
      - 생성시점: 프로그램 실행시 변수 생성됨 
        제거시점: 프로그램 종료시 변수가 삭제됨.
      - 생성횟수: 1 번
      - 저장메모리: method area 메모리  
      - 선언만하고 초기화하지 않으면 자동으로 기본값으로 초기화된다.
        기본형:
	    정수: 0
	    실수: 0.0
	    문자: \u0000
	    논리: false

	참조형: null
	  
6. 변수 특징

  1) 변수명이 동일하면 안됨
  2) 로컬변수는 사용전에 반드시 초기화
     초기화 안하면 컴파일 에러가 발생됨.

  3) 변수를 인식하는 범위 ( scope )
    ==> 블럭(중괄호{})

7. 상수 ( Constant )
  - 상수는 값 변경 불가
  - final 키워드 이용함.
  - 변수와 구별하기 위해서 대문자로 지정 ( 관례 )
  예> final int NUM=100;


8. 데이터형 변환

  1) 개념
    - 한번 선언된 데이터형은 언제든지 변경이 가능하다.
    - 큰박스에 작은 박스는 저장이 가능하고
      역은 저장불가

  2) 형변환 종류

     (1) 자동 형변환( 묵시적, promotion, up-casting )

         가.  byte(1byte) > short(2byte) > int > long > float > double 
         나.  char(문자형) > int(정수형 )
             예>  int n = 'A';  //가능

	 다. 정수형중에서 int보다 작은 타입의 연산결과는  기본값인 int로 반환된다.
         라. 작은 데이터형과 큰 데이터의 연산결과는 큰 데이터형으로 반환된다.
	    예> 정수형하고 실수형하고 연산결과는 실수형으로 반환된다.

         마. 문자열+비문자열(문자열)=====> 문자열로 반환


     (2) 강제형변환 ( 명시적, type casting, down-casting, 일반적으로 의미하는 형변환 )

         - 작은타입 = 큰타입; //에러

	 - 작은타입 = (작은타입)큰타입;  // 형변환 연산자: (타입)

  3) 현재는 기본형만 형변환 실습을 했음.
     하지만 참조형(클래스)도 형변환이 가능하다. (*************************)
     결론은 자바의 모든 데이터(기본형,참조형)는 형변환이 가능하다.




9. 콘솔(console)에 값을 출력하는 방법
  
   - 출력 대상은 다양하다.
     모니터에 출력하는 경우를 표준출력(standard output) 이라고 한다.
     반대 개념인 표준입력(standard input)은 키보에서 입력받는것을 의미한다.

  1) System.out.println(값); 
    - 새로운 줄(new line)에 출력한다.
    - 반드시 하나의 값만 지정한다.

  2) System.out.print(값);
    - 새로운 줄 없이 현재줄에 출력한다.
    - 반드시 하나의 값만 지정한다.

  3) System.out.printf("  ", ...);  // ... 는 가변인자라고 하고 갯수는 정해져 있지 않음

   예> System.out.printf("  ", 값); 
      System.out.printf("  ", 값1, 값2);
      System.out.printf("  ", 값1,값2,값3,값4,값5);

     String name ="홍길동";
     int age = 20;
     System.out.printf("이름:%s, 나이:%d", name, age);
############################################################################
###### 참고할만한 사이트 소개 ##############################################
############################################################################
# Java 타입 형변환 원리 & 방법
https://inpa.tistory.com/entry/JAVA-%E2%98%95-%ED%83%80%EC%9E%85-%ED%98%95%EB%B3%80%ED%99%98-%EC%A2%85%EB%A5%98-%EB%B0%A9%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC

# final 키워드
https://www.devkuma.com/docs/java/final/
https://sudo-minz.tistory.com/135

# printf(), 이스케이프 문자, 형식 지정자
https://damy.tistory.com/3

# 그림으로 보는 자바 코드의 메모리 영역 (스택 & 힙)
https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EC%9E%90%EB%B0%94-%EC%BD%94%EB%93%9C%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD%EC%8A%A4%ED%83%9D-%ED%9E%99

############################################################################
############################################################################
2일차 리뷰
1.JDK11 + eclipse2022 설치
  - JDK11 설치후 환경변수 설정
   JAVA_HOME=~
   PATH=~

2. 자바의 데이터 종류

  1) 기본형
       - 수치형
               - 정수형: byte ( 1byte )
	               short ( 2byte )
		        int  ( 4byte ): 기본
			long ( 8byte )
		   리터럴 표현: 10진수, 2진수(0b값), 8진수(0값), 16진수(0x값)
		             long 타입으로 정수값을 표현: 값L
	       - 실수형: float ( 4byte )
	               double  (8byte ): 기본
                   리터럴 표현: 소수점 이용, 지수 표현 가능
		             3.14 ( 3.14D, 3.14d)==> double처리
			     3.14F(3.14f)  ==> float 처리

       - 문자형 : char( 2byte )
                리터럴 표현: '' 이용, 단 하나의 문자 표현시 사용
		          'A', 'a', '홍'
			  escape문자: \t,\n, \', \", \\
	      * 자바언어는 하나의 문자와 여러 문자인 문자열을 구별해서 관리하다.
	        문자열은 참조형인 String 클래스로 관리된다.
       - 논리형 : boolean ( 1btye )
               리터럴 표현: true/false

  2) 참조형

     - 기본형 8개를 제외한 나머지 데이터
     - 클래스, 인터페이스, 배열


3. 변수(variable)
 
 1) 용도: 데이터 저장
 2) 특징: 단 하나의 데이터만 저장 가능
         동일한 이름으로 사용불가 ( 식별불가 )
	 블럭 scope를 따른다. ( 블럭({})안에서 선언된 변수는 블럭안에서만 사용 가능 )
	 * 자바스크립트 언어는 블럭 scope가 아니고 함수 scope를 따른다.

  3) 사용방법

     가. 변수선언 ( 메모리에 데이터를 저장할 영역생성, 영역의 이름을 변수로 지칭)
     나. 초기화
     다. 변수 사용

 4) 변수 종류 3가지

    가. 로컬변수(local variable)
       - 메서드안에서 선언된 변수
       - 생성~소멸: 메서드호출생성~메서드종료시삭제됨. 
       - 사용메모리: stack
       - 변수선언만하고 초기화 안하면 자동으로 초기화가 안됨.
         따라서 변수사용전에 반드시 초기화해야 된다. (*****)
    나. 인스턴스변수(instance variable)
       - 메서드밖에서 선언된 변수
       - 생성~소멸: 클래스 객체생성(new키워드)~ 객체소멸시 삭제됨.
       - 사용메모리: heap
       - 변수선언만하고 초기화 안하면 자동으로 초기화 ( 데이터형의 기본값으로 초기화됨, 정수:0, 실수:0.0 논리:false, 참조형: null )
    다. 클래스 변수 ( class variable, static variable)
      - 메서드밖에서 선언된 변수 + static 키워드
      - 생성~소멸: 프로그램실행시 생성 ~  프로그램 종료시 삭제됨.
      - 사용메모리: method area
      - 변수선언만하고 초기화 안하면 자동으로 초기화  ( 데이터형의 기본값으로 초기화됨, 정수:0, 실수:0.0 논리:false, 참조형: null )

 
4. 데이터 형변환
 
  - 개념: 한 번 정해진 데이터형이 계속 일정하지 않고 필요시 언제든지 변경될 수 있다.
  - 종류
   
    가. 묵시적 형변환( 자동형변환, promotion, up-casting)
        - byte > short > int > long > float > double
        -         char > int
        - int 보다 작은 타입의 연산결과는 int로 반환됨.
	- 작은타입과 큰타입의 연산결과는 큰 타입으로 반환됨.
	- 문자열과 비문자열(문자열)을 + 하면 연결이 됨.
	    
    나. 명시적 형변환( 강제형변환, type casting, down-casting )
      
       - (데이터형)값  형변환 연산자를 사용.
       - 단점은 데이터 손실이 발생될 수 있다.

5. 표준 출력

  - 모니터에 출력
  - 3가지
   System.out.println(값);  // 새로운 라인에 값을 출력
   System.out.print(값);    // 현재 라인에 값을 출력

   System.out.printf("포맷", 값,값2.....);  //   ... 가변인자, 현재 라인에 값을 출력

6. 상수( Constant )
 
  - final 키워드 이용
  - 상수는 값 변경이 불가능.
############################################################################
3일차 ( 3월 12일) 

1. 표준 입력 ( standard input )

  1) 개념: 키보드로 데이터를 입력 받음을 의미

  2) 모니터: System.out
     키보드: System.in

  3) java.util.Scanner 클래스 이용해서 키보드에서 입력된 값을 얻을 수 있다.

     import java.util.Scanner;

     Scanner scn = new Scanner(System.in);

   4) 값을 얻을 수 있는 메서드가 제공된다.

      정수값: int n = scn.nextInt();
      하나의 단어: String s = scn.next();
       예> 키보드 입력: aaa bbb ccc

      한 줄 읽기 : String s = scn.nextLine();



2. 문장 ( statements )

  가. 실행문 :  순차문 : 위에서 아래로 순차적으로 실행되는 문장.
                     거의 90% 이상 차지.

              제어문 :  조건문(분기문) : 조건에 따라서 실행되는 문장이 달라진다.
                                    단일if문, if~else문, 다중if문, switch문

	               반복문 : 조건에 따라서 한번 실행된 문장이 여러번 실행된다.
		                    for문,  while문, do~while문
			   
  나. 비실행문
     - 주석문 : 한줄 주석문 : // 
               멀티 주석문: /*   */
	      javadoc 주석문: /**   */  ==> 개발자가 만든 클래스에 대한 메뉴얼인 API문서 만들때 사용됨.
	                    

  1) 조건문 ( 분기문 )

    가. 단일 if 문
      -용도: 조건식(true/false)에 따라서 실행여부가 결정되는 경우.
      -문법: 
             if(조건식)문장1;
	             문장2;  // 영향이 없음.

             // {} 지정을 권장함.
             if(조건식){문장1;}
	             문장2;

             // {} 역할은 그룹핑 역할.
             if(조건식){
	        문장1;
	        문장2;
	     }
	             

    나. if~else 문
      -용도: 조건식(true/false)에 따라서 실행하는 문장이 달라지는 경우.
      -문법:
             if(조건식)
	        문장2;  // 조건식이 true인 경우에 실행
	     else
	        문장3;  // 조건식이 false인 경우에 실행


            if(조건식){
	        문장2;  // 조건식이 true인 경우에 실행
	     }else{
	        문장3;  // 조건식이 false인 경우에 실행
	     }


     다. 다중 if~else 문
      -용도: 여러번 비교할 때  사용된다.
      -문법:
          
	    if(조건식1){
               문장1;  // 조건? 조건식1이 true인 경우
	    }else if(조건식2){
               문장2;  // 조건? 조건식1은 false, 조건식2는 true
	    }else if(조건식3){
               문장3; // 조건?  조건식1은 false, 조건식2는 false 조건식3는 true
	    }

	     if(조건식1){
               문장1;  // 조건?
	    }else if(조건식2){
               문장2;  // 조건? 
	    }else if(조건식3){
               문장3; // 조건?
	    }else{
               문장4; // 조건? 조건식1은 false, 조건식2는 false 조건식3는 false
	    }

############################################################################
###### 참고할만한 사이트 소개 ##############################################
############################################################################
연산자
https://tadaktadak-it.tistory.com/7
https://hongong.hanbit.co.kr/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%97%B0%EC%82%B0%EC%9D%98-%EB%B0%A9%ED%96%A5%EA%B3%BC-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84/

# 자바 제어문
https://raccoonjy.tistory.com/10
############################################################################
############################################################################
    참조형 데이터
교재 p177 - 배열
    p128 - 객체와 클래스
############################################################################
3일차 리뷰

1. 연산자 (Operator)

  1) 산술연산자
     + ( 수치데이터 이용하면 연산은 더하기로 처리됨. 
         문자열과 다른값(문자열,비문자열)을 + 하면 연결되어 반환됨
	  예> System.out.println("홍길동 "+20 );
	 )
     -
     *
     / (정수값으로 나누기하면 결과값은 정수값으로 반환. 10/3=>3, 10/3.0=3.3333333 )
     % (나머지)

  2) 대입연산자
    용도: 변수에 임의의 값을 저장(할당,대입)하는 역할.
     
     a=b;  // a에 b를 저장(할당,대입)함.
     a+=b; // 풀어쓰면 a=a+b; 동일
     a-=b; // 풀어쓰면 a=a-b; 동일
     a*=b; // 풀어쓰면 a=a*b; 동일
     a/=b; // 풀어쓰면 a=a/b; 동일
     a%=b; // 풀어쓰면 a=a%b; 동일

   예> 새로운 변수 m을 선언하고 n 변수에 저장된 값을 저장하시오.
      int n = 10;
      int m = n;
      n=20;

   3) 비교연산자
     용도: 값(기본형)을 비교하는 기능. 실행결과는 논리값(true/false) 반환됨.
          ( 참조형은 클래스,인터페이스,배열은 비교연산자를 사용할 경우가 거의 없다. )
     a==b;  // a와 b가 같냐?
     a!=b;  // a와 b가 같지 않냐?
     a>b;   // a가 b보다 크냐?
     a>=b;  // a가 b보다 크거나 같냐?
     a<b;   // a가 b보다 작냐?
     a<=b;  // a가 b보다 작거나 같냐?
      ( 자바스크립트에서는  ===, !== 추가됨 )

    4)논리 연산자
      용도:  논리값(true/false)을 이용해서 연산하는 기능.  실행결과는 논리값(true/false) 반환됨.

      && : 논리값1 && 논리값2  ==> 논리값1 과 논리값2 가 모두 true인 경우에만 최종적으로 true가 반환됨.
           '그리고(and)' 로 해석.

      || : 논리값1 || 논리값2 ==> 논리값1 과 논리값2 중에 하나라도 true인 경우에 최종적으로 true가 반환됨.
           '또는(or)' 로 해석.

      !  : !논리값  ==> 논리값이 true면 false로  false면 true로 반환됨.
           부정연산자라고도 부른다.

      * short circuit logical 연산자
        ==> &&또는 || 연산자 앞의 논리값만 확인해서 최종적인 결과가 반환되는 메커니즘.

    5) 비트 연산자
      &
      |
      ^
      ~

    6) 증감연산자 ( 증가 연산자와 감소 연산자 )
      용도:  임의의 변수값을 1씩 증가하거나 1씩 감소하는 기능

      문법:  ++변수명;  // 전치
            변수명++;  // 후치  

	    --변수명:  // 전치
	    변수명--;  // 후치

	   ==> 위와 같이 다른 연산자 없이 독자적으로 사용하는 경우에는
	      전치 및 후치 결과는 같다.

	   변수명2 = ++변수명1;  // 전치,  먼저 증가하고 나중에 할당
	   
	   변수명2 = 변수명1++;  // 후치,  먼저 할당하고 나중에 증가

	  ==> 위와 같이 다른 연산자와 같이 사용하는 경우에는
	      전치 및 후치 결과에 따라서 변수명2의 값이 달라질수 있다.

     7) 3항 연산자
       용도: 조건을 이용해서 임의의 값을 얻을 때 사용
       문법:
            변수명 = (조건식)?참문장:거짓문장;

       특징: 중첩이 가능.
            if~else문과 비슷한 기능.

  
2. 표준입력
 개념: 키보드로부터 임의의 데이터를 입력 받음을 의미
 문법:
      import java.util.Scanner;

      Scanner scan = new Scanner(System.in);

      int num = scan.nextInt();
      String s = scan.next();    // 하나의 단어
      String s = scan.nextLine(); // 한 줄
############################################################################
4일차 ( 3월 13일 )

1. 문장 (statement )

  가. 실행문
      - 순차문
        : 위에서부터 아래로 순차적으로 실행되는 문장
        : 대부분의 문장에 해당, ;(세미콜론) 끝남

      - 제어문
        : 조건에 따라서 실행되는 문장이 달라지거나 또는 반복될 수 있는 문장
	 - 조건문(분기문) : 단일 if문 : 특정문장을 조건에 따라서 실행여부가 결정되는 경우.
	                 if~else문: 조건에 따라서 실행되는 문장이 다른 경우.
			 다중 if문:  조건이 여러개인 경우에 사용됨. 조건에 사용되는 연산자는 다양하다.
			 switch문:  조건이 여러개인 경우에 사용됨. 조건에 사용되는 연산자 지정안함.
			            (내부적으로 == 만 사용)
				    break문 사용가능

	 - 반복문 :  for문
	            while문
                   do~while문
	        * 반복문에서 사용되는 2가지 키워드
		  - break문
		  - continue문

  나. 비실행문
      - 주석문
      - 한줄 주석: //
        멀티 주석: /* */
	javadoc주석: /** */


2. 조건문: 단일 if문

 용도: 특정문장을 조건에 따라서 실행여부가 결정되는 경우.
 문법:
     1) {}(블럭) 지정 안한 경우 ( 권장안함 )
	     // if조건식에 영향을 받는 문장은 문장1 만 해당됨. ( 문장2는 영향이 없음)
	     // 조건식이 true인 경우는 문장1이 실행되고 false면 실행 안됨.
	     if(조건식) 문장1;
	              문장2;

     2) {}(블럭) 지정한 경우 ( 권장함 )

           if(조건식){
	      문장1:
	   }	      
	   문장2;


3. 조건문: if~else문

 용도: 조건에 따라서 실행되는 문장이 다른 경우.
 문법:

   1) {}(블럭) 지정 안한 경우 ( 권장안함 )
      - 조건식이 true이면 if블럭인 문장1 실행되고 false이면 else블럭인 문장2가 실행된다.
      if(조건식)
         문장1;
      else
         문장2;

   2) {}(블럭) 지정한 경우 ( 권장함 )

      if(조건식){
         문장1;
      }else{
         문장2;
      }

4. 조건문: 다중 if문

 용도: 조건이 여러개인 경우에 사용됨. 조건에 사용되는 연산자는 다양하다.
      
 문법: 

     1) {}(블럭) 지정한 경우 ( 권장함 )

      if(조건식1){
         문장1;
      }else if(조건식2){
         문장2;
      }else if(조건식3){
         문장3;
      }

 특징: 조건식에 사용될 수 있는 연산자는 다양하다.

5. 변수 scope 
 개념: 자바의 변수는 기본적으로 블럭scope를 따른다.
      블럭({})안에서 선언된 변수는 블럭안에서만 사용할 수 있고
      블럭밖에서 사용이 불가능하다.
 
    main(){

      int num= 10; //로컬변수
      if(true){
         System.out.println(num);
         int num2 = 20; //로컬변수
         System.out.println(num2); 
      }
      System.out.println(num);
      System.out.println(num2);  //에러 발생
    }//end main

6. switch문
  용도: 조건이 여러개인 경우에 사용됨. 조건에 사용되는 연산자 지정안함.
      (내부적으로 == 만 사용)
  특징: break문 사용 및 미사용 가능하다. (옵션기능)
       ==> break문이 없으면 일치된 case 문 이후의 모든 문장이 실행된다.
       switch문에 사용되는 변수의 데이터 타입은 6가지만 가능하다.
       ( byte,short,int, char, String, enum )
       case 문에는 중복값 지정 불가
  문법:
       switch(변수){
	  case 값1(리터럴): 문장;
	                 break;	// switch문을 빠져나옴.
          case 값2(리터럴): 문장;
	                 break;	// switch문을 빠져나옴.
          ..
	  default: 문장;
       }

7. 반복문
 
 예>   Hello 5번 출력하시오.

  횟수:
   1   Hello 출력
   2   Hello 출력
   3   Hello 출력 
   4   Hello 출력
   5   Hello 출력
   6   중단
  
   10
   8
   6
   4
   2

 필요한 3가지 요소
 1) 시작값 필요 : 1 ==> 변수사용 
    int n=1;
 2) 증가/감소 연산 필요: ==> 연산자 이용 
    1씩증가/감소: ++n,  --n
    2씩증가/감소: n=n+2; n=n-2; 
                n+=2;  n-=2;
 3) 값비교하는 연산 필요: ==> 조건식
     n<6


  1) for문 ( 반복회수 예측이 쉽게 가능한 경우 )
  문법;
       for(시작값(초기값); 조건식; 증감연산자){
           문장1;
	   문장2;
       }

   예> for(int n=1;n<6;++n){
         System.out.println("hello");
      }

  *주의: 
    위 3가지 구성요소(시작값,조건식,증감연산자)가 
    하나라도 빠지면 원하는 반복이 안 될수 있다.
    무한루프에 빠질수 있다.


  2) while 문 ( 반복회수 예측이 어렵거나 또는 무한루프 )
   - 반드시 3가지 구성요소(시작값,조건식,증감연산자)가 필요하다.
   -문법:

        시작값;
        ..
       while(조건식){
            문장;
	증감연산자;
       }

   //무한루프
    while(true){

    }

  3) do~while문
  - 반드시 3가지 구성요소(시작값,조건식,증감연산자)가 필요하다.

  문법:

       시작값;
       do{
         
	 문장;
	 증감연산자;
       }while(조건식);

   특징: while문은 조건이 처음부터 false라면 한번도 문장이 실행되지 않는다.
   하지만 do~while 문은 나중에 조건식이 실행되기 때문에 조건이 처음부터 false라도 반드시 1번은 문장이 실행된다.
   
   결론은 조건과 무관하게 무조건 1번은 실행해야되는 경우라면 do~while문을 사용한다.


8. break문, continue문
 
  1) break문
   용도:  반복문을 빠져나올때 사용.
   문법:
         if(조건식)break;

        for(int n=1; n <= 5; n++ ){
	      //n값이 3일때 중단
              if(n==3)break; //1128라인으로 점프
              System.out.println("hello");
	}

        System.out.println("END");

    
  2) continue 문
   용도: 반복해야되는 여러 문장들중 특정문장들을 특정회차에서 skip할 때 사용.
   문법:
         if(조건식)continue;

	for(int n=1; n <= 5; n++ ){
	   if(n==3)continue;  // 1141라인으로 점프. 반복문의 끝(})으로 ...
           System.out.println("hello" + n);
	}

        System.out.println("END");



--------------------------
 * 자바에서 데이터 저장방법 3가지 (외우기)
 1) 변수(variable)
    - 값(데이터) 하나만 저장이 가능
    - 데이터 개수만큼 변수가 필요하다.
      관리가 어렵다.
    - 저장되는 값이 기본형: 기본형 변수
      저장되는 값이 참조형(클래스,배열,인터페이스): 참조형 변수

 2) 배열(array)
    - 여러개의 값(데이터)을 저장이 가능.
    - 배열에 저장하는 데이터형은 동일해야 된다.
    - 크기변경이 불가
    - 배열자체는 참조형이고 저장되는 데이터는 기본형 및 참조형도 가능하다.

 3) 컬렉션 ( Collection API )
    - 여러개의 값(데이터)을 저장이 가능.
    - 컬렉션에 저장하는 데이터형은 달라도 무관.
    - 크기변경이 자동.
    - 컬렉션자체는 참조형이고 저장되는 데이터는 참조형만 가능하다. ( 기본형은 wrapper클래스를 이용해서 저장가능)
    - 종류 3가지 ( 클래스로 제공 )
    (1) List 계열
        - 저장순서가 있음. 중복이 가능하다.
    (2) Set 계열
        - 저장순서가 없음. 중복이 불가(1번만 저장됨)
    (3) Map 계열
        - name(key)와 value(값) 을 쌍으로 저장
	- 순서가 없음.
	- 동일한 name(key)은 저장하면 값을 덮어쓴다.
--------------------------

9. 배열(array)

 용도: 데이터 저장
 특징: 참조형 데이터이다. 
      참조형인 배열은 반드시 저장영역을 만들 때 new 이용한다. (********************)
      저장되는 메모리는 heap이다.
      한번 생성된 배열은 크기 변경이 불가능하다. ( 크기를 늘리고 싶으면 배열을 다시 new 해야 된다. )
      배열에 저장되는 데이터는 기본형 및 참조형 모두 가능하다.
      1차원 및 다차원 배열 생성이 가능하다.

 사용방법:
    1) 배열 선언
    문법: 데이터형 [] 배열명;   // 배열명은 변수명과 동일

        // 기본형인 int 저장용
        int [] num;   or  int num [];

      * 구별해야 되는 것
        int num;  // num 의 데이터타입? int, 기본형
	             num에 저장될 수 있는 값? int인 정수

	int [] num2;  // num2 의 데이터타입? int [], 참조형
                         num2 에 저장될 수 있는 값? 주소값

   2)  배열생성 ( new 이용 )

     문법: 배열명 = new 데이터타입[크기];

          num = new int[3];  // 크기 3을 가진 배열이 heap 메모리에 생성된다.
	                     // heap에 생성되기 때문에 자동초기화가 된다.

   3) 배열요소접근
    문법: 생성된 배열의 인덱스(첨자) 사용해서 접근한다.
         인덱스는 0부터 시작한다. 배열길이보다 항상 1이 작다. 
	 배열길이: 배열명.length

	 배열명[인덱스];

	 System.out.println(num[0]);
	 System.out.println(num[1]);
	 System.out.println(num[2]);
         //System.out.println(num[3]); // 없는 요소 접근시 예외 발생됨. java.lang.ArrayIndexOutOfBoundsException
	 System.out.println(num.length)


    4) 배열요소 접근 방법

       가. 직접 인덱스 지정
         예> num[0]
	  ==> 접근할 요소가 많으면 비효율적임.

       나. (일반) for문 이용
         예>
	    for(int idx=0; idx < num.length; idx++){
               System.out.println( num[idx] );
	    }
	  ==> 단점은 조건을 잘못 지정하면 예외가 발생된다.
	   
       다. 향상된 for문 ( foreach 문 )

          문법: 
	        for(변수: 배열명 ){

		}

         예>  for( int n : num ){
		 System.out.println(n);
	      }


10. new 이용한 방법 이외의 방법 2가지 살펴보기
 
    1) new 이용
      예> int [] num;
          num = new int[3];
          num[0]=10;
	  num[1]=20;
	  num[2]=30;

    2) 리터럴(값) 이용 ( ************ )
    문법:
          데이터형 [] 배열명 = { 값, 값2, 값3,....  };
     
      예> int [] num = {10, 20, 30};

    특징: 한번에 구현해야 된다.

         int [] num;
	  num = {10, 20, 30}; // 에러 발생

    3) new + 리터럴 혼합 형태 ( *********)

    문법:
          데이터형 [] 배열명;
	  배열명= new 데이터형[]{ 값, 값2, 값3,....  };
     
      예> int [] num;
          num = new int[]{10, 20, 30};
############################################################################
4일차 리뷰
1.제어문

  1) 조건문(분기문)
   
      - 단일if문 : 조건식에 따라서 실행여부가 결정됨.
         문법:
	       if(조건식){
                  문장1;
		  문장2;
		  ..
	       }
  
      - if~else문: 조건식에 따라서 실행되는 문장이 달라지는 경우에 사용됨. 
         문법:
	       if(조건식){
                  //조건식이 true인 경우에 실행
	       }else{
                  //조건식이 false인 경우에 실행 
	       }

      -조건식이 여러개
         가) 다중 if문
            - 명시적으로 연산자를 지정함. 예> ==, > , >= ,....
	    문법:
	         if(조건식1){

		 }else if(조건식2){

		 }else if(조건식3){

		 }

	 나) switch문
	    - 명시적으로 연산자를 사용안함.
	      묵시적으로 == (동등연산자) 사용함.
            문법:
	         switch(변수){
                   case 값1: 문장1; break;
                   case 값2: 문장2; break;
		   ..
		   default: 문장n;
		 }
            - break문은 옵션.
	    - switch문에서 사용 가능한 데이터 타입은 6개이다.
	      ( byte,short,int, char, String, enum )

    ==> 변수scope는 블럭scope를 따른다.
       즉 블럭({})내에서 선언된 변수는 블럭안에서 사용이 가능하다. 

  2) 반복문
     - 구성요소 3가지 
        가. 시작값(초기값)
	   예> 1 0 10
	나. 조건식
	   예> n < 5
	다. 증감식

     - 종류

     가. for문
       문법:
           for( 초기값 ; 조건식  ; 증감식 ){

	   }
       -용도: 반복횟수 예측이 가능한 경우에 사용됨.

     나. while문
       문법:
            초기값;
            while(조건식){
                문장;
		증감식;
	    }
        -용도: 반복횟수 예측이 힘든 경우 ( 무한루프 )
	-특징: 조건식값에 따라서 문장이 한번도 실행안될수도 있다.

     다. do~while문
        문법:
             초기값; 
	     do{
                문장;
		증감식;
	     }while(조건식);
	 -용도: 반복횟수 예측이 힘든 경우
	 -특징: 조건식값에 따라서 문장이 적어도 한 번은 실행될 수 있다.


2. 배열(array)

  1) 자바에서 데이터를 저장할 수 있는 3가지 방법 (외우기)
    가. 변수
      - 단 하나의 값만 저장이 가능하다.
      - 값의 종류는 기본형 및 참조형 모두 가능.
          예>  기본형 변수 : n변수에 가면 10(실제값)이 저장되어 있음.
	      int n = 10; // n 변수의 데이터타입은 ? 기본형데이터타입, int 타입

	      참조형 변수 : name 변수에 가면 "홍길동"이 저장된 주소값이 저장되어 있음.
	      String name =  "홍길동";  // name 변수의 데이터타입은?  참조형 데이터타입, String 타입

    나. 배열 ( 참조형이다.)
      - 여러개의 값 저장 가능. 단, 동일한 데이터형만 가능.
      - 값의 종류는 기본형 및 참조형 모두 가능.
        예>
	   기본형 배열: num 변수에 가면 10,20,30 이 저장된 배열의 주소값이 저장되어 있음.
	   int [] num = { 10,20,30}; // num 변수의 데이터타입은 ? 배열타입, 참조형 데이터타입, int형의 배열타입

           참조형 배열: name 변수에 가면 "홍길동","이순신" 이 저장된 배열의 주소값이 저장되어 있음.
	   String [] name = { "홍길동","이순신" };// name 변수의 데이터타입은 ? 배열타입, 참조형 데이터타입, String 형의 배열타입
 
    다. 컬렉션 ( 참조형이다.)
      - 여러개의 값 저장 가능. 데이터타입이 달라도 가능.
      - 값의 종류는 참조형만 가능하다. (기본형은 wrapper 클래스형태로 저장가능 )

      기본형          wrapper 클래스
      ----------------------------
      byte		Byte
      short		Short
      int		Integer
      long		Long
      float		Float
      double		Double
      char		Character
      boolean		Boolean

 2) 1차원 배열 생성 방법

   가. new 이용
      문법;
           데이터타입 []  변수(배열명);
	   변수 = new 데이터타입[size];
           배열명[idx];

	   배열명.length;

   나. 리터럴 이용
      문법:
             데이터타입 []  변수(배열명) = { 값, 값2, ... }; // 반드시 한 라인에 생성해야 된다.
             배열명[idx];
             배열명.length;

   다. new + 리터럴 혼합
       문법:
            데이터타입 []  변수(배열명);
	    변수 = new 데이터타입[]{ 값, 값2, ... }; // 명시적으로 size지정 불가

	    배열명[idx];
	    배열명.length;
 
  3) 배열 순회 방법

    가. 일반 for문 
        int [] num = {10,20,30};     
      
        for(int idx=0; idx < num.length; idx++){
            System.out.println( num[idx]);
	}

    나. foreach 문 ( 향상된 for문 )
       int [] num = {10,20,30};  

       for(int n : num ){
          System.out.println(n);
       }
###################################################################
5일차 ( 3월 14일 )

1. 2차원 배열
  
  1) 정방형
    가. new 이용
        데이터타입 [][] 배열명 = new 데이터타입[행크기][열크기];

    나. 리터럴 이용
        데이터타입 [][] 배열명 = { { 값1, 값2 }, { 값1, 값2}, {값1, 값2} }; 
    
    다. new + 리터럴 혼합
        데이터타입 [][] 배열명 = new 데이터타입[][] { { 값1, 값2 }, { 값1, 값2}, {값1, 값2} }; 
  
  2) 비정방형
     가. new 이용 ( 행크기만 지정 )
        데이터타입 [][] 배열명 = new 데이터타입[행크기][];
         // 열은 나중에 생성
	 배열명[0]=new int[열크기];

    나. 리터럴 이용
        데이터타입 [][] 배열명 = { { 값1 }, { 값1, 값2, 값3}, {값1, 값2} }; 
    
    다. new + 리터럴 혼합
        데이터타입 [][] 배열명 = new 데이터타입[][] { { 값1 }, { 값1, 값2, 값3}, {값1, 값2} }; 
    

2. 커맨드 라인 아규먼트 배열 ( command line arguments )

   1) public static void main( String [] args ){}

      - 모든 메서드는 기본적으로 파라미터 가질수 있다.
        파라미터(parameter): 메서드명( 변수, 변수2,... ){ 로컬변수}
      - 파라미터는 로컬변수에 속함. 따라서 stack 저장됨.
      - 아큐먼트(arguments, 인자값)는 파라미터(변수)에 저장되는 값을 의미한다.


   2) 실행할 때 값을 설정할 수 있다. 

      예> Hello.java
                   <== c:\> javac Hello.java 
         Hello.class
	           <== c:\> java Hello  10 20 


   3) 이클립스에서 arguments(인자값) 설정하는  방법

     *.java 선택하고 오른쪽클릭 > Run as > Run configuration > arguments 탭에
       공백을 구분자로 값을 설정 > Run 선택.

3. 문자열 형태의 정수인 "10" 값을 실제 정수로 변경하는 방법
    "10"===> 10
   예> int num = Integer.parseInt("10"); // num에는 정수 10이 저장됨.


4. 랜덤값 얻기
  - java.util.Random 클래스 이용

  - 방법
   1) Random 클래스 객체 생성
      
       import java.util.Random;

       Random r = new Random();

   2) 랜덤값 반환하는 메서드 사용

      int n = r.nextInt();
      int n2 = r.nextInt(3); // 0, 1, 2 중에서 랜덤하게 반환
      float f = r.nextFloat(); 
      double d = r.nextDouble();
      boolean b = r.nextBoolean(); 
#######################################################
5. 클래스

  1) 객체(object) ?
    - 주체(subject)가 눈으로 보여지는 사물의미.
     예> 모니터 객체, 
        노트북 객체,
	책상 객체,
	학생 객체,....
  2) 객체(object)의 구성요소 2가지
     예> 학생객체
     가. 속성
        - 객체를 표현할 수 있는 특성
        - 예> 학번, 이름, 전화번호, 주소, ....
	
     나. 동작(기능)
         - 객체의 행위.
	 - 예> 등교하기, 공부하기, 하교하기,... 졸기(X)
 
   3) 객체지향 프로그래밍 ( Object Oriented Programming: OOP )
    - 현실세계에 존재하는 속성과 동작 구성요소로 되어있는
      객체(object)라는 개념을 이용해서 프로그래밍하는 방법론.
    - 대표적 언어: 자바

   4) 자바에서는 객체(object)를 어떻게 표현할까? (***************)

    현실세계             OOP               가상세계(자바 프로그래밍)
    ------                            --------------------
    고양이 객체    --------------------------> 클래스로 표현 ( Cat 클래스 )
    -속성: 이름,나이,성별... ------------------> 변수로 표현 (인스턴스 변수)
    -동작(기능):먹기,뛰기,... -----------------> 메서드로 표현

   5) 만들어지 클래스 사용할려면 ?

     - 반드시 클래스를 사용할려면 객체생성해야 된다. (********************)
     - 객체생성은 new 키워드 이용
     문법:
           클래스명  변수명 = new 클래스명(); ( 외우기 )
      예> 

          main(){
	    Cat c = new Cat(); 
          }

        1번: Cat c 수행
	    - c 가 로컬변수 ( stack 저장 )
	           참조변수 ( 주소값 저장, 참조하면 Cat이 있음 )
		   Cat 타입의 변수

         2번:  new Cat 수행
	    -  heap 메모리에 Cat 을 생성.
	    -  heap 메모리에 생성된 Cat을 인스턴스(instance)라고 부른다.
	       인스턴스안에 있는 구성요소인 변수와 메서드를 멤버(member)라고 부른다.
	    -  heap 메모리에 생성된 변수를 인스턴스 변수(멤버변수)라고 한다.
            -  heap 메모리에 생성된 메서드를 인스턴스 메서드(멤버메서드)라고 한다. 

        3번: Cat()
	    - 생성자 호출하는 코드이다.

         4번: =
	    - heap 메모리에 생성된 Cat 인스턴스 주소값을 
	      c에 할당한다.
	    - 이후에 Cat 인스턴스의 구성요소(변수,메서드)를 접근하기 위해서는
	      c 참조변수를 이용한다.
	      방법: c.변수/c.메서드()
################################################################
6. Cat 클래스 작성

  1) 특징
     - 현실세계의 고양이 객체를 추출하고 
       자바언어로 프로그래밍하기 위해서 만든 클래스이다.
     - 2가지 구성요소를 가짐 (변수와 메서드 )
       변수는 현실세계의 고양이 객체의 속성을 표현하기 위함.
       메서드는 현실세계의 고양이 객체의 기능(동작)을 표현하기 위함.

     - 주의할 점은 main 메서드를 지정하지 않는다. (*************)
       이유는 재사용하기 위함이다. ( 클래스 재사용 )
       main메서드가 없기 때문에 실행이 안됨.
       실행하기 위해서 main메서드를 가진 임의의 클래스(핸들링 클래스)를 추가해야 된다.

      결론:
            Cat 클래스 (main 없음)

	    TestCat 클래스 ( main 있음, Cat 핸들링 역할: 객체생성등.... )
############################################################################
###### 참고할만한 사이트 소개 ##############################################
############################################################################
# 자바 참조 타입 - 배열
   https://kephilab.tistory.com/37
# java new
  https://yoo11052.tistory.com/52
# 배열 선언 및 초기화 방법 정리
   https://non-stop.tistory.com/3
# 2차원 배열과 동적할당
   https://jwj1699.tistory.com/3
#  다차원 배열(2차원 배열)
   https://ococ99.tistory.com/38
# Java main Argument 관련 자료
   https://velog.io/@98kimjh/Java-Main-Arguments
   https://storyjava.tistory.com/171
   https://skillazit.tistory.com/2
# 객체 지향 프로그래밍 개념
  https://victorydntmd.tistory.com/117
# 클래스 및 객체 생성과 사용법
  https://kadosholy.tistory.com/89
  https://sime.tistory.com/41
# 객체 생성과 참조 변수 / this
   https://we1cometomeanings.tistory.com/6
############################################################################
############################################################################
############################################################################          
5일차 리뷰
1. 배열(array)

  용도: 같은 타입의 데이터를 여러개 저장가능한 방법.
  특징: 같은 타입만 저장 가능.
       한번 생성된 배열은 크기변경이 불가. ( 크기변경할려면 다시 생성해야 된다.)
       배열은 참조형( 배열명(변수)는 주소값을 갖는다. )
       배열에 데이터는 기본형 데이터(8개)도 가능하고 참조형 데이터(클래스)도 가능하다.
       배열의 요소접근은 인덱스(첨자)를 이용하고 0부터 시작한다. 예>  배열명[idx]
       배열의 길이는 배열명.length 를 사용한다.

   사용방법: 
     1) 배열선언
       데이터타입 [] 배열명;  // 배열명의 데이터타입은 ( 데이터타입 [] ), 참조형이기 때문에 주소값을 갖는다.
       데이터타입 배열명 [] ;

     2) 배열생성 ( new )
       배열명 = new 데이터타입[size];  // 생성된 배열이 heap 메모리에 생성됨. heap 메모리에 생성된 변수는 자동초기화됨.

     3) 배열초기화 // 인덱스를 이용, 0부터 사용가능
       배열명[idx]=값;

     4) 배열크기
       배열명.length;

    배열생성 3가지 방법
      1) new 이용
         int [] num;
	 num = new int[3];
	 num[0]=10;
	 num[1]=20;
	 num[2]=30;

      2) 리터럴 이용
         int [] num = {10,20,30};
   
      3) new + 리터럴 이용
         int [] num;
	 num = new int[]{10,20,30};

2. 2차원배열 ( 다중행/다중열 로 구성 )

   1) 정방형배열 ( 모든행의 열의 길이가 동일. 특징은 하나의 new로 행과 열을 동시에 생성.
      가. new 이용
          int [][] num;
	  num = new int[2][2]; // new int[행크기][열크기] 2X2
	
	  num[0][0]=10;
          num[0][1]=20;
	  num[1][0]=30;
	  num[1][1]=40;

	  행의길이: num.length
	  1행의 열길이: num[0].length

      나. 리터럴 이용
          int [][] num = { {10,20},{30,40}};

      다. new + 리터럴 이용
          int [][] num = new int[][]{ {10,20},{30,40}};

   2) 비정방형배열 ( 행의 열의 길이가 다르다. 특징은 하나의 new 로 행을 만들고 여러번의  new로 열을  생성 )

      가. new 이용
          int [][] num;
	  num = new int[2][];  // 행부터 생성

	  //나중에 열을 만듬
	  num[0]=new int[1];
	  num[1]=new int[3];

          //배열초기화
	  num[0][0]=10;
	  num[1][0]=20;
	  num[1][1]=30;
	  num[1][2]=40;

      나. 리터럴 이용
          int [][] num = { { 10 },{20,30,40}};

      다. new + 리터럴 이용
         int [][] num = new int[][]{ {10},{20,30,40}};

    =====> 배열 사용시 Arrays 클래스의 도움을 받으면 배열처리를 손쉽게 할 수 있다.


3. Integer.parseInt("10")
  역할: "10" 는 연산불가.
       연산하기 위해서 "10" 를 10로 변경해야 된다.
       예>  int num = Integer.parseInt("10");
           float f = Float.parseFloat("3.14");

4. 랜덤값 얻기
   - java.util.Random 클래스 이용
   - 사용방법:
       
       Random r  = new Random(); // Random의 구성요소 ( 변수와 메서드 )

       r.nextInt()
       r.nextInt(n)
       r.nextFloat()
       ..

5. 클래스
 
 가. 객체(object)
    정의: 현실세계의 존재하는 사물의미.
         만약에 A 동물병원에서 '애완동물 관리'하는 프로그램 개발 의뢰를 받았음.
	 주문(order)---> 분석 ---> 설계----->구현 -----> 테스트 -----> 배포
	 분석단계의 핵심작업: 애완동물관리 프로그램에 적합한 객체(object)를 추출.
	                 예> 고양이객체(속성과동작), 강아지객체(속성과동작)

 나. 클래스(class)
    정의: 분석단계에서 추출한 고양이 객체(속성과동작)를 자바에서 표현하는 방법.
        고양이객체 ---------------------> 고양이클래스인 Cat
	속성     --------------------->  인스턴스변수
	동작     ----------------------> 메서드

	public class Cat{
           //속성인 인스턴스 변수
	   String name;
	   int age;
	   String gender;

	   //동작인 메서드
	}

 다. 인스턴스(instance)
    정의: 2마리 관리한다고 가정
         예> 야옹이 2 암컷 ,   망치 1 수컷

	 main(){

	 Cat c1 = new Cat();
	 c1.name="야옹이";
	 c1.age=2;
	 c1.gender="암컷";


         Cat c2 = new Cat();
	 c2.name="망치";
	 c2.age=12;
	 c2.gender="수컷"; 

	 
#############################################################################
6일차 (3월 15일 )
0. 클래스 문법:
    접근지정자 class 클래스명{
    
    }
    
    2. 클래스명 
     - 사용자 정의 식별자
     - 반드시 첫글자는 대문자
     - 의미있는 명사형
     
    3. 클래스 구성요소
      - 변수(멤버, 멤버변수, 인스턴스 변수)
      - 메서드(멤버, 멤버메서드)
      - 생성자(constructor): 멤버에 포함안됨.
      
    4. 클래스 사용
      - 반드시 객체 생성해야 된다.
        객체 생성 작업을 '인스턴스화' 한다고 함.
      - new 이용. 생성된 클래스는 heap메모리에 인스턴스로 생성됨.
      - 문법:
         
           클래스명  변수명 =  new 클래스명([값,값2,..]);
           
1. 생성자 ( constructor )

  역할: heap메모리에 생성된 인스턴스내의 인스턴스 변수를 초기화하는 역할.
       인스턴스를 직접 접근할수도 있으나 권장안함.
       이유는 잘못된 데이터를 필터링없이 저장이 가능하기 때문이다.
       예> c1.age=2000;  // 논리적으로 문제가 있음.
       
  문법:
        public 클래스명([변수,변수,...]){
            // 인스턴스 변수초기화
	}

  특징:
     - 생성자가 수행이 될려면 반드시 생성자를 호출해야 된다.
       호출방법: 
                new Cat();  // Cat() 코드가 생성자를 호출하는 코드이다.

      - 생성자는 명시적으로 지정할 수도 있고 자동으로 지정될 수 있다.
        자동으로 지정되는 생성자의 형식은 다음과 같다. ( 기본생성자, default 생성자 라고 부른다. )
	   public 클래스명(){

	   }
        단, 명시적으로 생성자를 지정하면 기본생성자는 생성안됨. 
	이유는 기본생성자로 new 하지 말고  명시적으로 지정한 생성자로 new 하라는 의미이다.
	필요시 기본생성자를 명시적으로 지정할 수 있다.
      - 필요시 생성자를 여러개 지정할 수 있다.
        식별이 가능하기 위해서 반드시 생성자([파라미터,...])의 파라미터인 인자리스트는 달라야 된다..
	argument list(인자리스트)는 갯수 또는 타입 또는 순서가 달라야 된다.
        이렇게 하나의 클래스에 여러개의 생성자를 지정할 수 있고 이것을 '오버로딩(overloading) 생성자'라고 부른다.

      - 생성자이용한 초기화 장점 2가지
        1) 생성자안에서 값의 유효성체크가 가능하다.
	2) 직접접근한 방법보다 훨씬 빠르게 초기화가 가능하다.

      - 오버로딩 생성자 지원하는 이유?
        사용자가 모든 인스턴스변수의 값을 알고 있지 못한 경우도 있다.
	따라서 알고있는 값만 초기화하는 역할의 오버로딩 생성자가 필요하다.

      - 이클립스에서 오버로딩 생성자 코드를 자동으로 추가할수 있게 지원됨.

2. 지정자(modifier)

   1) 접근지정자 ( access modifier  )
     ==> 순서중요
      
       public : 제한이 없음.
       protected
                (default)
       private: 외부클래스에서는 접근이 불가능. 내부(자신)에서는 접근가능.

    ==> 접근지정자 사용가능한 경우
        -클래스
        -메서드
	-로컬변수 제외한 인스턴스 변수 및 클래스변수에 사용 가능
        -생성자

   2) 일반지정자 ( standard modifier)
    - static
    - final
    - abstract
    - transient,..

3. this 키워드

  1) 개념: heap 메모리에 올라간 인스턴스 자신의 주소를 참조한다.
       this는 생략할 수 있다.

  2) 반드시 명시적으로 this를 지정해야 되는 경우가 있음.
    ==> 인스턴스변수명과 메서드및생성자의 파라미터변수명이 동일한 경우이다.
        문법: this.변수, this.메서드();
      예>  
          public class Cat{

              String name; //인스턴스변수
	    
	   public Cat( String name ){ // 로컬변수(파라미터)
                this.name = name;
	   }

     ==> 생성자에서 다른 생성자를 호출할 때
        문법: this([값,값2,..]);
	 예> this(); ==>  Cat() 호출
	    this("야옹이",2) ==>  Cat(String name, int age) 호출
            this("야옹이",2, "암컷") ==>  Cat(String name, int age , String gender) 호출 
        
	주의: 반드시 생성자 첫라인에서 지정해야 된다.

       예> public Cat(String name, int age, String gender) {
		this.name = name;
		this.age = age;
		this.gender = gender;
	  }
	  public Cat(String name, int age) {
	       this(name, age, "암컷") ;
	  }


4. 메서드(method)

  1)클래스 구성요소 역할
   
     public class Cat{

          // 인스턴스 변수: 객체의 속성을 저장하는 용도. this.변수 가능.(일반적으로 this생략)
	                 직접 접근 방지 위해서 private로 지정한다.
          private  int age;

	  // 생성자 : 인스턴스 변수의 초기화 용도. 오버로딩(overloading 가능 ), this(값,..) 이용해서
	             다른 생성자도 호출가능.
          public Cat(int age){
             this.age = age;
	  }

	  // 메서드 : 다양한 기능처리 용도.
	            지금은 age라는 인스턴스 변수를 수정 또는 조회하는 역할로 메서드를 작성할 것이다.
     }

   2) 메서드 문법

     문법:
           // 메서드
           public 리턴타입 메서드명([변수,변수,..]){
	       문장1;
	       문장2;
	       [return 값;] //리턴값
	   }

	   // 생성자
	   public 클래스명([변수,변수,...]){
               문장1;
	   }

    생성자와 차이점: - 리턴타입을 반드시 지정해야 된다.
                 - 리턴값을 가질수 있다.
		 - 메서드명은 임의로 지정 가능 ( 생성자는 반드시 클래스명으로 지정해야 된다. )

    생성자와 공통점: 반드시 호출해야 된다.
               
	       가. 생성자 호출 방법
		  a. 다른 클래스에서 호출
		     - new 클래스명([값,값...]);

		  b. 자신이 호출
                     - this([값,값...]);

	       나. 메서드 호출 방법
                  - 인스턴스 변수와 (인스턴스)메서드는 우선 인스턴스화가 되어야 된다.
		   따라서 객체생성(new)후 메서드를 호출할 수 있다.

		   Cat c = new Cat(); // heap 메모리에 인스턴스 변수와 인스턴스 메소드가 생성됨.

		   c.메서드([값,값...]); // 객체생성후 참조변수.메서드() 형식 사용.

      * 메서드 특징
         - 메서드명은 사용자 정의 식별자이기 때문에 임의로 지정 가능 ( 권장은 동사형, 소문자 )
	 - 반드시 호출해야 된다.
	 - 호출후 수행이 끝나면 호출한 곳으로 반드시 돌아온다.

   3) 메서드 형태 ( 파라미터가 있거나 없거나 또는 리턴값 있거나 없거나 )

    가.  파라미터가 없고 리터값도 없는 형식
      문법:
           public void 메서드명(){
               문장;
	   }
	예> 
	 public class Util{
	   public void method1(){
		System.outprintln("method1");
	   }
         }
      사용방법: 
	  Util u = new Util();
	  u.method1();

 
   나.  파라미터는 있고 리터값 없는 형식
      문법:
           public void 메서드명(변수,...){
               문장;
	   }

      예> 
	 public class Util{
	   public void method2(int n){
		System.outprintln("method2" + n);
	   }
	   public void method3(int n, int n2){
		System.outprintln("method2" + n + "\t" + n2);
	   }
         }

       사용방법: 
	  Util u = new Util();
	  u.method2(10);
	  u.method3(10,20);

#####################################################################
6일차 리뷰 

7일차 ( 2024년 3월 18일 )
1. 클래스
  - 자바의 최소한의 단위.
  - 구성요소
    변수(인스턴스변수, 멤버변수): 객체의 속성 저장용
    메서드(인스턴스메서드, 멤버메서드): 기능처리용. 일반적으로 변수의 핸들링 역할(수정, 조회)
    생성자: 변수 초기화용

  -문법:
        public 클래스명{ // 사용자정의 식별자, 첫글자 대문자, 의미있는 명사형 
	 
	    //인스턴스 변수
	    // 생성자
	    // 메서드

	}

  - 사용방법: 작성된 클래스는 반드시 객체 생성해야 된다.
      문법:
           클래스명  변수명 = new 클래스명([값, 값,...]);
     
      ==> 클래스의 멤버(인스턴스변수,메서드)가 heap 메모리에 생성된다.
          heap 메모리에 생성된 것은 '인스턴스(instance)'라고 부른다.


2. 생성자 ( constructor )
  
  역할: 인스턴스변수 초기화
  문법:
       public 클래스명([변수,..]){}

  특징: -반드시 호출해야 실행된다.
       ==> 호출방법 2가지
         가. 다른 클래스에서
	     new 클래스명([값,..]);
	 나. 자신 클래스에서
	     this([값,..]);

       -반드시 클래스명으로 지정해야 된다.
       -개발자가 명시적으로 생성자를 지정하지 않으면 자동으로 생성자를 제공한다. ( 기본 생성자, default 생성자 )
        ==> public 클래스명(){}
        단 개발자가 명시적으로 생성자를 지정하면 기본 생성자는 제공이 안된다.
       -오버로딩(overloading) 생성자가 가능하다.
        ==> 개념: 하나의 클래스안에 동일한 이름의 생성자가 여러개 지정이 가능함.
	==> 규칙: 반드시 인자 리스트(파라미터)가 다르면 가능하다.
	         인자리스트는 갯수,타입,순서 의미.
        ==> 장점: 재사용성 목적

3. 메서드 (method)
 
  1)용도: 기능처리. 
         일반적으로 인스턴스 변수와 관련된 기능처리이다. ( 변수값 수정, 변수값 조회, 유효성검사 기능등 )

  2)문법:
   
       public 리턴타입 메서드명([변수,...]){  // 파라미터는 없거나 여러개 지정 가능
	   문장1;
	   [return 값;]  // 리턴값,  리턴값은 없거나 반드시 한개만 지정 가능
       }

  3)특징:
       - 반드시 호출해야 실행된다.
         ==> 호출 방법은 ?
	    가. 다른 클래스에서
	        step1: 반드시 객체생성해야 된다.
		       클래스명  참조변수명 = new 클래스명([값,..]);
                step2: 참조변수명.메서드([값,...]);
 
	    나. 자신 클래스에서
	         step1: 반드시 객체생성해야 된다.
		       클래스명  참조변수명 = new 클래스명([값,..]);

		 step2: this.메서드([값,...]);
		        또는
                        메서드([값,...]);

  4) 메서드의 파라미터 및 리턴값의 따른 4가지 형식

    가. 파라미터 없고 리턴값 없는 경우
      문법:
         public class 클래스명{
           public void 메서드명(){
              문장;
	   }
	   public void 메서드명2(){
              문장;
	      this.메서드명(); //  메서드명();
	   }
	 }

      사용:
           클래스명  참조변수명 = new 클래스명();
           참조변수명.메서드명();

    나. 파라미터 있고 리턴값 없는 경우
      문법:
          public class 클래스명{
 
             public void 메서드명1(int n){
	     }
	     public void 메서드명1(String n){
	     }
	     public void 메서드명1(String n, int n2){
	     }
	  }
        사용:
           클래스명  참조변수명 = new 클래스명();
           참조변수명.메서드명1(10);
	   참조변수명.메서드명1("홍길동");
	   참조변수명.메서드명1("홍길동", 10);
 
     *오버로딩 메서드 ( overloading )
     - 개념: 하나의 클래스안에 동일한 이름의 메서드가 여러개 지정이 가능하다.
          단 식별하기 위해서 인자리스트( 갯수, 타입, 순서 )를 반드시 달라야 된다.
     - 장점: 재사용


    다. 파라미터 없고 리턴값 있는 경우
     문법:
          public class 클래스명{

	     public 리턴되는값타입 메서드명(){
                   문장1;
		 return 값;  // 리턴되는 값: 리턴값
	     }
	  }
	 예>
	    public int x(){
		문장;
		return 100;
	    }
           public String x(){
		문장;
		return "홍길동";
	    }
     사용:
          클래스명  참조변수명 = new 클래스명();
          리턴값저장용변수 =  참조변수명.메서드명();


    라. 파라미터 있고 리턴값 있는 경우

     문법:
          public class 클래스명{

	    public 리턴타입 메서드명(변수,변수2,...){
               문장;
               return 값;
	    }
	  }

	예> public int sum(int n, int n2){
              return n+n2;
	   }

     사용:
           클래스명  참조변수명 = new 클래스명();
          리턴값저장용변수 =  참조변수명.메서드명(값, 값2);


4. 메서드 호출시 파라미터에 전달하는 값(인자값,argument)인 기본형 vs 참조형

   => call by value   vs call by value Reference

   1) call by value
     ==> 메서드 호출시 파라미터에 인자값으로 기본형 데이터를 전달 할 수 있다.
     이때 전달받은 메서드에서 값을 수정할 수 있음. 원본은 변경 안됨.


   2) call by value Reference
     ==> 메서드 호출시 파라미터에 인자값으로 참조형 데이터(클래스, 배열)를 전달 할 수 있다.
     이때 전달받은 메서드에서 값을 수정할 수 있음. 원본이 변경됨.
       이유는 전달되는 인자값이 주소값이기 때문이다.

5. static 키워드 ( 정적 )

  1) 개념:  프로그램 실행과 관련된 키워드임. ( 객체생성인 new와 무관, 객체생성 전에 결정된다. )
           static 으로 지정된 변수 및 메서드, 클래스는 프로그램 실행시 생성이 된다. (************)

  2) 로컬 변수 vs 인스턴스 변수 vs static 변수
  
     로컬변수: 메서드안에서 선언. 메서드 호출~ 메서드종료. stack메모리
     인스턴스변수: 메서드밖에서 선언.  객체생성(new)~객체소멸.heap 메모리
                객체소멸시점? heap에 생성된 인스턴스를 참조 못할 때
                사용방법?  
		   Cat c = new Cat();
		   c.변수명;
                생성횟수? new할 때마다 매번 생성된다. (공유 안됨)
	        용도: 객체의 속성 저장 예> 고양이 이름,나이

     static변수: 메서드밖에서 선언하고 static 지정. 프로그램실행~프로그램 종료, method area메모리
                프로그램실행시점? run > main 시작
                프로그램 종료시점?   main 종료
		==> 객체생성(new)과 무관하다. (*****************)
		    객체생성(new)전에 생성된다.
                사용방법? 클래스명.static변수;
		생성횟수? 한번만  생성된다. 
		용도: 한번만 생성되고 가장 lifecycle 길다. ==> 데이터를 공유할 목적

  3) 메서드(인스턴스 메서드,멤버 메서드 ) vs static 메서드

     메서드(인스턴스 메서드,멤버 메서드 ): 메서드 생성시점? new 할때(객체생성) 생성
                                   메서드 소멸시점? 객체소멸시 제거
				   사용방법?  
				           Cat c = new Cat();
					   c.메서드명();
                                   생성횟수? new할 때마다 매번 생성된다.
				           (실제로는 공유한다.)
				   
     static 메서드:   메서드 생성시점? 프로그램실행시 생성
                    메서드 소멸시점? 프로그램 종료시 제거
		   ==> 객체생성(new)과 무관하다. (*****************)
		       객체생성(new)전에 생성된다.
		    사용방법? 클래스명.static메서드();
		    생성횟수? 한번만  생성된다.
		    용도: new 없이 사용할 목적이다.
		      예> Integer.parseInt("10");
                    *주의할점
		     - 인스턴스 변수 및 this 키워드 사용불가 ==> 아직 인스턴스가 생성 안됨.
		     - 상속관련에서는 오버라이딩(Overriding) 불가


 4) 일반 클래스 vs static 클래스
   
   ==> static 클래스는 반드시 중첩 클래스에서만 사용이 가능하다.
      * 중첩클래스
       
        public  class A{ // 외부클래스, outer class )
	   //변수
	   //생성자
	   //메서드

           //클래스 (중첩클래스, nested class, inner class )
	  static class B{

	  }//end B

	}//end A
   
   ==> A 클래스는 반드시 new 해야 된다.
   하지만 B클래스는 프로그램실행시 자동으로 생성된다.

  
   5) static 블럭 ( *********** )

   ==> 문법:
    
           static{
              실행문;
	   }

     특징: 프로그램 시작할 때 자동으로 실행된다.
          초기화 작업 ( 예> DB 및 파일 연동시 )



6. package 및 import

  1) package 
   가. 용도: 클래스 파일들 관리용 ( 윈도우의 폴더 역할 )
   나. 문법

         package 패키지명;  // 단일패키지
         package 패키지명.패키지명2;  // 서브패키지 지정 가능.  권장 2~3
	 package 패키지명.패키지명2.패키지명3;

     ==> 실행결과는 폴더처럼 보인다.

   다. 특징:  -같은 패키지안에는 동일 이름의 클래스 지정 불가.
              역으로 패키지가 다르면 동일 이름의 클래스 지정이 가능.
	    - 패키지가 다르면 접근이 불가.
	      접근이 가능한 방법은 import 문 이용한다.
            - 하나의 프로그램안에 동일한 이름의 패키지를 사용 불가.
	      ==> 개발자가 만든 프로그램은 패키지명이 유일해야 된다.
	      ==> 가상세계에서 유일한 값으로 패키지명을 지정한다.
	          도메인(domain)으로...........
		  예> package com.ssginc;
	    - Java API는 패키지로 제공된다.
	      예> java.lang
	         java.util
		 ...
               ==> java 또는 javax 로 시작하는 패키지는 사용하면 안됨.
            - package문은 단 한번만 지정 가능.
  2) import 문

    문법:  import 패키지명.패키지명1.클래스명;

    특징:  -import문은 여러번 지정 가능
          -java.lang은 자동으로 import가 된다.
	   따라서 String, System 클래스들을 import 없이 사용할 수 있다.
           역으로 java.lang 제외한 나머지는 무조건 import해야 된다.
     

 7. UML ( Unified Modeleing  Language )
  개요: 설계단계에서 추출된 다양한 산출물들을 도식화하는 도구.

  클래스 다이어그램(class diagram)

 예>
  
  public class Cat{

    private String name;
    public int age;
    protected Strign gender;

    public Cat(){}
    public Cat(String name, int age, String gender){}

    public void setName(String name){}
    public String getName(){}


  }

############################################################################
###### 참고할만한 사이트 소개 ##############################################
############################################################################
# 클래스의 구성 멤버[생성자]
   https://kephilab.tistory.com/47
# 생성자의 목적, 특징, 사용법
   https://kadosholy.tistory.com/91
# 생성자의 조건
   https://hunit.tistory.com/155
# 생성자 오버로딩과 메서드 오버로딩
  https://hunit.tistory.com/156
  https://m.blog.naver.com/heartflow89/220956516175
# 변수의 종류 - 로컬, 인스턴스, static 변수…
  https://kadosholy.tistory.com/91
  https://j-growthdiary.tistory.com/entry/변수의-종류클래스-변수Static-변수인스턴스-변수지역-변수
# static변수와 static 메소드
   https://mangkyu.tistory.com/47
# 클래스, 객체, 인스턴스의 차이
   https://javakid.tistory.com/8
# 메소드의 정의와 4가지 유형
   https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=lunatic918&logNo=155768994
# 메서드와 return문
  https://bskwak.tistory.com/223
# getter와 setter는 왜 사용하는걸까?
 https://velog.io/@cksdnr066/getter-와-setter-는-왜-사용하는걸까
# Java - 데이터형(Data Type) ⇒ PDT / RDT
   https://jin-vv.tistory.com/m/30
# 객체 지향 클래스 문법 - 한방 가이드
   https://inpa.tistory.com/entry/JAVA-☕-객체-지향OOP-클래스-문법-💯-총정리
# 패키지란? (package, import, classpath…)
   https://doozi0316.tistory.com/entry/JAVA-7주차-패키지-package-import-classpath
# 패키지, import, 접근제어자
   https://wordbe.tistory.com/211
# 클래스 다이어그램
   https://velog.io/@godkimchichi/Java-13-클래스다이어그램
# UML
  https://www.nextree.co.kr/p6753/
# Static? 그거 왜 붙이는건데?
   https://jooona.tistory.com/164
# Static
   https://wikidocs.net/228
# 자바 static의 의미와 사용법
   https://kingofbackend.tistory.com/131
# Static block이 뭐지?
  https://velog.io/@betterfuture4/Static-block이-뭐지
# 스태틱 블록(Static block)
   https://kingofbackend.tistory.com/131
# 초기화와 초기화블럭
  https://kamang-it.tistory.com/entry/Java-14초기화와-초기화블럭Initialize-Block
# 스태틱 블록, 인스턴스 블록, 생성자
  https://uoonleen.tistory.com/6

############################################################################
7일차 리뷰
1. 클래스 구성요소
  - 인스턴스 변수: 데이터 저장용. 객체 속성값 저장 예> Cat의 이름,나이
                일반적으로 private 지정한다.( 은닉화(캡슐화, encapsulation)
                private 로 지정하여 직접접근이 불가능함.

  - 생성자(constructor) : 인스턴스 변수 초기화용. 
                        반드시 클래스명으로 사용.
			오버로딩(overloading) 생성자가 가능 ( 단 인자리스트(갯수,타입,순서)는 반드시 다르다. )
			반드시 호출해야 실행이 된다.
			호출하는 방법은 2가지 ( 외부: new 생성자(); 내부: this() )
  - 메서드(method) : 기능처리. 일반적으로 인스턴스변수를 관리하는 기능임. ( 변수값 수정, 조회, 유효성검사,..)
                   역할에 따른 2가지 종류: 값설정용은 setter 메서드 사용. 값 조회용은 getter 메서드 사용.
                   파라미터및리턴값존재여부에 따른 4가지 종류: ~
                   반드시 호출해야 실행이 된다. 실행된후에 반드시 호출한 곳으로 돌아온다. ( stack메모리에 함수정보저장)
                   오버로딩(overloading) 메서드가 가능 ( 단 인자리스트(갯수,타입,순서)는 반드시 다르다. )

2. call by value vs call by value reference
  개념: 메서드 호출시 값을 전달할 수 있는데
       전달되는 방식은 값이 전달된다.
  
  값의 종류:  기본형인 경우에는 call by value 라고 한다. ( 실제값이 전달됨 )
             ==> 전달받은 메서드안에 값을 변경하면 원본값을 영향을 받지 않는다.

            참조형인 경우에는 call by value reference 라고 한다. ( 주소값이 전달됨 )
             ==> 전달받은 메서드안에 값을 변경하면 원본값도 영향을 받는다.
	     예> 배열 또는 클래스 전달하고 전달받은 메서드에서 값을 변경하면 
	        원본배열 또는 클래스(Cat, 컬렉션)의 변수값이 수정이 된다.

3. package 와 import

   1) package
     -용도: 클래스 파일 관리목적 ( 윈도우의 폴더와 비슷 )
      문법:  package 패키지명;
            package 패키지명.패키지명1;

      특징:  단한번만 지정 가능.
            유일한 값으로 지정. ( 일반적으로 도메인으로 지정함 )
	    패키지 컴파일 필요:  javac -d Hello.java
            패키지 실행시 패키지명을 명시적으로 지정해야 된다. :  java com.ssginc.Hello 	     
            java API도 패키지로 제공된다. ( java.lang, ... javax.... )
	    사용자지정 패키지명은 java API 패키지명은 사용불가
	    패키지가 다른 클래스는 접근이 불가능.===> 해결: import

    2) import
      용도: 패키지가 다른 클래스는 접근이 불가능한데 가능하도록 경로를 알려주는 역할.
      문법:   
            import 패키지명.패키지명1.클래스명; // 권장함
	    import 패키지명.패키지명1.*;      // 권장안함

           이클립스에서 ctrl+shift + o (영문자) 하면 자동으로 import 됨.

     특징: 자동으로 import 되는 API 패키지는 java.lang이다.
          역으로 java.lang 제외한 나머지는 무조건 import 해야 된다.

4. static 키워드
  
  특징: new(객체생성)와 무관하고 프로그램실행할 때 정해짐.(정적특징)
  사용: 
       클래스: 중첩클래스에서만 사용 가능. ( 외부클래스는 사용불가 )
       변수 : static변수(클래스변수), 프로그램 실행시 method area에 생성됨. 단 한번만 생성됨.
             목적은 new한 여러 인스턴스들이 공유할 수 있다.
       메서드: static 메서드. 프로그램 실행시 method area에 생성됨.
             목적은 new 없이 메서드 사용할수 있다. ( 예> Integer.parseInt("10") )
	     주의할점은 new에 의한 인스턴스와 무관하기 때문에 
	     인스턴스변수, this 키워드를 사용할 수 없다.
  접근방법:  클래스명.변수
           클래스명.메서드();

5. static 블럭
  용도: 프로그램에서 특정 작업을 초기화(선처리)가 필요한 경우이다.
       초기화는 생성자 또는 메서드에서도 가능하다. 하지만 추가작업이 필요하다.(객체생성, 호출)
       그런데 static 블럭은 추가작업이 필요없음.

  문법:
       static{
          //초기화 작업
       }
############################################################################

8일차 강의내용
1. 상속
2. 다형성
3. java.lang.Object 클래스
4. 접근지정자
5. 추상클래스
6. 인터페이스
7. 중첩 클래스
############################################################################
8일차 강의 ( 3월 19일 )

1. 클래스 관계 ( Class Relationship )

  1) has a (use a) 관계
    
     - 예>  트럭 has a 엔진.
          트럭 has a 라디오.
          학생 has a 노트북.

    -  has a 관계를 자바표현? (***************)

      public class Truck{
	  Engine e;  // Truck has a Engine 라고 할 수 있다.
      }
      public class Engine{

      }

    - 관계종류 2가지
       composition: 트럭 has a 엔진. UML: 채워진 마름모
       aggregation: 트럭 has a 라디오. UML: 빈 마름모

  2) is a 관계 ( 상속관계 , ****************)

     - 예>  고양이 is a 애완동물.
            중학생 is a 학생.
	    엔지니어 is a 사원.

    -  is a 관계(상속)를 자바표현?
       extends 키워드 이용

      // 큰 개념 ( 큰 데이터 타입 )
      // 정확한 표현: 부모 클래스, super 클래스, parent 클래스
      class Employee{

      }
      // 작은 개념 ( 작은 데이터 타입 )
      // 정확한 표현: 자식 클래스, sub 클래스, child 클래스
      class Engineer extends Employee{  // Engineer is a Employee 라고 할 수 있다. 이것이 상속관계이다.

      }

   - 상속특징
     1) 반드시 is a 관계가 성립해야 된다.
     2) Engineer is a Employee 경우에는
        Engineer 를 자식클래스, sub 클래스, child 클래스라고 하고
        Employee 를 부모 클래스, super 클래스, parent 클래스라고 부른다.
	중요: 부모인 Employee가 자식인 Engineer 보다 더 큰 타입이라고 할 수 있다. (*************)
     3) extends 부모클래스 형식을 사용한다.
     4) 단일 상속(single inheritance)만 지원됨.
       ==> extends 뒤에 명시한 부모클래스는 하나만 지정 가능.
     5) 명시적으로 extends 가 없는 클래스는 자동으로 extends Object가 지정된다.
      ==>  class Employee{} 지정하면 자동으로
           class Employee extends Object{} 가 된다.
     6) 상속을 UML로 표현할 때는 삼각형+실선으로 표현
     7) java.lang.Object클래스는 최상위 클래스이다.

     8) 상속을 하면 가장 큰 장점은 재사용이 가능하다.
        부모에서 정의한 변수및메서드를 자식에서 정의없이 그냥 사용할 수 있다.
	이것을 상속해서 사용한다고 말하는 것이다.
  
     9) 상속이 안되는 2가지 경우
       - 생성자
       - private로 된 변수 및 메서드

     10) 자식에서 super 키워드를 사용할 수 있다.
     
       가. this 키워드
          -this는 heap메모리에 생성된 자신의 인스턴스를 가리킨다.
          - 일반적으로 this는 생략해서 사용된다.
            반드시 this를 명시적으로 사용해야 되는 경우 2가지
	     a. 인스턴스변수와 로컬변수 이름이 동일한 경우
	       ==> 문법: this.변수, this.메서드()
	     b. 다른 생성자 호출하는 경우
	        ==> 특정 생성자에게 인자값을 집중화해서 초기화하는 역할.
		==> 주의할 점은 반드시 첫 라인에서 사용해야된다.
                ==> 문법: this(), this(10);

       나. super 키워드
          -super는 heap메모리에 생성된 부모의 인스턴스를 가리킨다.
          - 일반적으로 super는 생략해서 사용된다.
          반드시 super를 명시적으로 사용해야 되는 경우 2가지

	     a. 부모의 변수와 자식의 변수 이름이 동일한 경우 ( 부모의 메서드와 자식 메서드가 동일한 경우 )
	       ==> 문법: super.변수, super.메서드()

	     b. 부모의 생성자 호출하는 경우
	        ==> 부모 생성자에서 초기화하는 역할.
		==> 주의할 점은 반드시 첫 라인에서 사용해야된다.
                ==> 문법: super(), super(10);

     11) 항상 자신보다 부모를 먼저 생성한다.
        ==> 매커니즘: 자식의 생성자 첫라인에서 자동으로 부모 생성자를 호출하는 코드가 삽입이 된다.
	            그 코드가 super() 이다.
        ==> 명시적으로 super() 사용할 수 있다.
	    반드시 첫라인에서 사용해야된다.

	결국은 Object 클래스가 가장 먼저 생성이 된다.
  
     12) 오버라이딩(overriding) 메서드가 가능하다.
        개념: 부모의 메서드를  자식이 재정의하는 것을 의미한다.
	규칙: 

	   부모:    접근지정자 리턴타입  메서드명(변수,..) throws 예외클래스{}

                    @Override ==> 어노테이션(annotation) 지정하여 오버라이딩된 메서드임을 알려줄 수 있다.
	   자식:     X    리턴타입  메서드명(변수,..) Y {} 

	    X 에는 부모에서 지정된 접근지정 레벨과 같거나 덜 엄격한 레벨값을 지정할 수 있다.

	     public 
	     protected
	           (default)
	     private

	    Y 에는 부모에서 지정된 예외클래스와 같거나 자식 예외클래스만 지정할 수 있다.

             Object
	        |
	     Exception
	        |
             RuntimeException
	        |
	     ArrayIndexOutofBoundsException, NullPointerException
	       
###############################
 OOP의 3대특징
 1. 상속 ( inheritance )
 2. 다형성 ( Polymorphism )
 3. 은닉화( encapsulation, 캡슐화 )
###############################

2. 다형성 ( Polymorphism )
 
   1) 개념
    - 하나의 참조변수가 타입이 다른 여러 인스턴스를 참조하는 능력이다.

   2) 특징
     - 상속이 전제 ( is a 관계이고 같은 종류 의미를 내포한다. )
     - 재사용성이 높아짐.
     - 하나의 변수로 서로 다른 기능을 가진 메서드(변수)를 호출할 수 있다.

   3) 문법:
     
      Object
        |
      Employee (부모, 큰 타입 )
         |        |
   Engineer     Manager (작은타입)


      가. 일반적인 방법

            Employee emp = new Employee();
            Engineer eng = new Engineer();
	    Manager  m = new Manager();
	    Secretary s = new Secretary();

      나. 다형성 적용한 방법

            Employee emp = new Employee();
                     emp = new Engineer();
	             emp = new Manager();
	             emp = new Secretary();

	 * 기본형
	   short s = 10;
	   int s2 = s;
  
   4) 다형성 활용

     가. 배열
       - 기본적으로 배열은 같은 타입만 저장된다. 
        다형성을 적용하면 다른 타입도 저장 가능하다.
	예>
	   // Employee배열이기 때문에 Employee 또는 자식들만 저장이 가능하다.
	   Employee [] emp = { new Employee(), new Engineer(),new Manager(),new Secretary() };
	
	   // 다형성을 확장해서 Object 배열을 만들면 모든 데이터를 저장할 수 있다.
	   Object [] obj ={"hello", new Employee(), new Random(), 10, 3.14};
  
     나. 메서드 파라미터 타입 (***************)
          ==>  다형성이 지원 안되면 여러개의 오버로딩 메서드가 필요하다.
	     하지만 다형성이 지원되어 하나의 메서드만 있으면 된다.
       예>
           public void a( Object  x){}
//오버로딩
public void a( String  x){}
public void a( int  x){}
public void a( boolean  x){}

	   a("hello");
	   a(10);
	   a(true);
        
	 public String printf( String s, Object ... obj)

	 System.out.printf( "", 10, 20, 30 );
	 System.out.printf( "", "hello" );
################################################
8일차 리뷰

1. OOP 3대 특징
  - 상속(inheritance)
  - 다형성 ( polymorphism )
  - 은닉화 ( encapsulation, 캡슐화)

2. 상속
  
 1) 개념: 클래스들간의 관계가 is a 가 성립됨. ( 같은 종류 )
 2) 구현:
      - UML 표기
         큰타입 클래스 ( Employee ) ( Pet ) <== 부모클래스, super 클래스, parent 클래스
             |
             |  <== extends 부모 클래스
	 작은타입 클래스 ( Engineer, Manager) ( Dog, Cat ) <== 자식클래스, sub 클래스, child 클래스
         
      - 코드 표현
          public class Employee{}  // public class Employee extends Object{} 동일 
	  public class Engineer extends Employee{}

 3) 특징
       - 재사용성이 증가됨. ( 부모의 변수,메서드를 상속받은 자식들은 그냥 사용가능 )
       - 상속불가 ( 부모의 생성자, private로 된 변수/메서드 ) 
       - 항상 자신보다 부모를 먼저 생성한다. ( 자식 생성자 첫라인에서 부모생성자를 호출하는 super() 자동삽입됨)
       - 모든 클래스의 부모는 Object가 된다. ( 다형성에서 가장 큰 타입으로 Object가 사용됨)
       - 명시적으로 부모의 변수/메서드   및  생성자를 호출 할 수 있다.
         부모의 변수/메서드: super.변수, super.메서드() ==> 자식클래스에 부모와 동일한 변수와 메서드가 존재할 때.
	 부모의 생성자 :  super()  ==> 자식 클래스의 생성자 첫 라인에서만 사용 가능.
	               super(name,salary) ==> 명시적으로 부모 생성자 호출하는 이유는 부모에서 선언된 변수이기
		                             때문에 부모에서 초기화할 목적이다.

       - 부모에서 상속받은 메서드를 필요에 의해서 다시 정의할 수 있다. ( Overriding, 재정의 )
         Overriding 규칙: - 반드시 부모 메서드의 리턴타입과 동일
	                 - 반드시 부모 메서드명과 동일 ( 재사용성 )
			 - 반드시 부모 메서드 파라미터와 동일
			 - 접근지정자는 같거나 덜 제한하는 지정자 사용
			 - throws 예외클래스는 같거나 자식 예외클래스 사용

         Overriding 불가: private 로 지정된 메서드.
	                 static 로 지정된 메서드.
			 final 로 지정된 메서드.

3. 다형성
 1) 개념: 상속이 전제. 
         단 하나의 참조변수(부모타입)가 타입이 다른 여러 인스턴스(자식타입)들을 참조할 수 있는 능력.
 2) 문법:
         큰타입  변수 = 작은타입;

	예> Employee emp = new Engineer();
	             emp = new Manager();

 3) 목적: 재사용성
 4) 다형성 활용
    가. 배열
        Employee [] emp = {new Engineer(), new Manager()};
  
        Object [] obj ={"hello", 2, true,... };

    나. 메서드 파라미터 ( Java API가 상당수 다형성을 적용 )
      => 오버로딩 메서드가 불필요함.

       public void a(Object obj ){}

       a(10);
       a("hello");
################################################################
9일차 ( 3월 20일 )

1. 다형성
   
  - 타입비교하는 방법 :  변수명 instanceof 클래스 : boolean반환
  - 형변환 :  필요시   작은타입 변수 =( 작은타입  )큰타입;

   예> 
     Employee [] emp = {new Engineer(), 
                        new Manager()
			new Engineer(),
			new Engineer(),
                        new Manager()
			};

    문제1: 배열에서 Manager만 출력하시오.

       for(Employee e: emp){
          if(e instanceof Manager){
             System.out.println(e.getEmployee());
	  }
       }

    문제2: 배열에서 Manager에 추가된 depart만 출력하시오.
       	   for(Employee e: empArray) {
		   if(e instanceof Manager) {
			   //형변환
			   Manager m =(Manager)e;
		      System.out.println(m.getDepart());
		   }
	   }

2. java.lang.Object 클래스

  - 모든 클래스들의 최상위 클래스 ( root 클래스 ).
  - 클래스생성(new)할 때 가장 먼저 생성되는 클래스.
  - 8개의 메서드를 구성요소로 가지고 있음.
   따라서 자식 클래스에서는 Object의 메서드를 그냥 사용할 수도 있고
   필요시 오버라이딩(Overriding) 할 수 있다.

 - Object의 toString() 
  ==> 문자열로 변환해주는 기능.(Returns a string representation of the object)
  ==> 자동으로 호출된다. ( 콘솔에 참조변수를 출력할 때 )
  ==>  getClass().getName() + '@' + Integer.toHexString(hashCode()) 구현되어 있음.
  ==> 사용자가 만든 클래스에서는 거의 대부분 오버라이딩해서 사용해야 되고
      Java API는 거의 100% 오버라이딩이 되어 있다.
      예> String s = "hello";
        
	 System.out.println(s);
	 System.out.println(s.toString());


   클래스작성 구성요소

     1. 변수
     2. 생성자
     3. getter/setter
     4. toString 오버라이딩
     5. 유효성체크 메서드 (옵션)



3. 접근지정자 ( access modifier )

  1) 용도:  클래스들간의 접근(참조)을 제한하는 방법.
  2) 4가지 레벨
                         같은 클래스인 경우  같은패키지의 다른클래스  다른패키지의 상속관계  다른패키지의 다른클래스
     public (+)              가능              가능                  가능              가능
     protected (#)           가능              가능                  가능              불가
          (default)          가능              가능                  불가              불가
     private  (-)            가능              불가                  불가              불가


4. 추상 클래스 ( abstract class )

 1) 문법:
         public abstract class 클래스명{


	 }


 2) 구성요소
     
      -변수
      -생성자
      -메서드( concrete method ): {} 를 가져서 기능이 정해짐.
         예> public void a(){
	       실행문;
	    }
      -추상 메서드(abstract method) : {} 를 지정안함. 기능이 미지정된 상태. 나중에 지정됨
         예>
	    public abstract void a();  // abstract 키워드 필수.
 
   => 추상클래스는 추상 메서드를 가질수도 있다.
      추상 메서드를 가지면 반드시 추상클래스로 만들어야 된다.

 3) 특징
     - 불완전한 클래스이다. 따라서 객체생성이 불가능하다. ( new 불가 )
     - 불완전한 클래스인 자신은 인스턴스가 안되지만 
       상속을 통해서 자식 클래스를 이용해서 추상클래스의 구성요소를 인스턴스화 할 수 있다.
   

       추상클래스 : public abstract class AAA {  // extends Object 자동지정됨
         -변수
	 -생성자
	 -메서드
	 -추상메서드: public abstract void a();
       }

          AAA x = new AAA(); // 에러발생

      자식클래스: public class BBB extends AAA{
         //부모의 변수 사용
	 //부모의 메서드 사용
         // 부모의 생성자 사용불가 (생성자는 상속안됨)
       
         // 부모의 추상메서드를 반드시 오버라이딩(overriding)해야하는 제약이 붙는다.
	   만약에 추상메서드를 오버라이딩하지 않으면 에러가 발생된다.
      }

   - 추상클래스는 불완전한 클래스이지만 상속관계이기 때문에
     자식클래스보다 큰 타입이다. 따라서 다형성을 적용할 수 있다.
      예> 
           AAA x = new  BBB(); //  다형성
  
   - abstract는 이탤릭체로 표현.

 4) 목적: 부모의 추상메서드를 반드시 자식클래스에서 오버라이딩(overriding)해야하는 제약을
        갖도록 하는 것이다.(메서드 강제) + 부모의 변수/메서드(concrete method)를 자식이 상속받아서 재사용.

     예>
      버전1: 일반 클래스 Pet인 경우
            Pet
               -name, age
	       -eat(){} // 자식인 Cat, Dog, Bird,...... 에서 eat기능의 메서드를 마음대로 작성 가능.관리어려움

    Cat                     Dog                   Bird
                                              @Override
eatCat(){s.o.u("쩝쩝");}  eatDog(){s.o.u("냠냠");}    eat(){s.o.u("짹짹");}

       버전2: 추상 클래스 Pet인 경우
           abstract Pet
               -name, age
	       -abstract eat(); // 자식인 Cat, Dog, Bird,...... 에서 eat() 메서드로만 사용하도록 강제.

    Cat                     Dog                   Bird
 @Override             @Override               @Override
eat(){s.o.u("쩝쩝");}  eat(){s.o.u("냠냠");}    eat(){s.o.u("짹짹");}


5. 인터페이스 (interface)

   1) 문법
           public interface 인터페이스명{
		int NUM = 20; // public static final int NUM = 20; 동일

		abstract void a(); // default 가 아니고 public
		void b();   // public abstract void b() 동일
	   }

           인터페이스명.java 로 저장됨

   2) 구성요소 4가지
       - 상수:   final int NUM =20;
              ==> public static final 지정자가 자동으로 지정된다.
              ==>접근은 인터페이스명.상수명 으로 사용한다. ( 인터페이스.NUM )
       - default 메서드
            ==> public default 리턴타입 메서드명([변수,..]){ 실행문;}
	    ==> 클래스의 인스턴스 메서드처럼 동작된다. 
	        따라서 default 메서드는 new 한 후에 사용이 가능하다.
       - static 메서드
           ==> public static 리턴타입 메서드명([변수,..]){ 실행문;}
            ==> 클래스의 static 메서드처럼 동작된다.
	        따라서 new 없이 인터페이스명.static 메서드 로 사용할 수 있다.

       - 추상 메서드 ( abstract method )
           ==> public abstract 리턴타입 메서드명([변수,..]); 
	   ==> public abstract 지정자가 자동으로 지정된다.
	     따라서 abstract 키워드는 생략할 수 있다. ( 추상 클래스의 추상 메서드에서는 abstract 필수 )
          예>
	      public interface Flyer{
                   void a();
		   void b();
                public abstract void c();
	      }

   3) 특징
       - 불완전 객체이다. 따라서 객체생성(new) 불가.
       - 불완전한 객체인 자신은 인스턴스가 안되지만 
         상속이 아닌 구현을 통한 자식 클래스를 이용해서 인터페이스의 구성요소를 인스턴스화 할 수 있다.
   
         예> 
                                                 인터페이스  인터페이스   
                                                         | (삼각형 실선, extends, 상속관계, 다중상속)
	    클래스 (큰)         추상클래스(큰)           인터페이스(A)   인터페이스(B)  (큰) 
	      | (삼각형 실선)      | (삼각형 실선)               |         |
	    클래스 (작은)        클래스 (작은)                   |         |   (삼각형 점선)
	                                                        클래스        (작은) 
           상속관계            상속관계                       구현관계(준상속관계)
           extends           extends                      implements A,B
           단일상속            단일상속                       다중구현
           다형성             다형성                         다형성
 
          하위클래스: public class B implements A{
         // 준부모(인터페이스)의 상수 사용
	 // 준부모의 default 메서드 사용
         // 준부모의 static 메서드 사용
       
         // 준부모의 추상 메서드를 반드시 오버라이딩(overriding)해야하는 제약이 붙는다.
	   만약에 추상메서드를 오버라이딩하지 않으면 에러가 발생된다.
          }

       - 구현시 implements 키워드 사용
       - 다중 구현이 가능하다. ( implements 인터페이스, 인터페이스2,.. )
       - 인터페이스간에도 상속관계이다. ( 인터페이스 extends  인터페이스 )
       - 인터페이스간에는 다중상속이 지원 (  인터페이스 extends  인터페이스,인터페이스2,.. )
       - 타입으로 인터페이스가 큰 타입이기 때문에 다형성 적용이 가능하다.
       - 명시적으로 인터페이스를 만드는 경우는 4가지 구성요소중 
         추상메서드를 사용하기 위한 것이다. 

   4) 목적1
      - 추상클래스와 동일하게 인터페이스에서 지정된 추상메서드명으로
        하위 클래스에서 사용하도록 강제할 수 있다.
      
         추상 클래스 Pet인 경우
           abstract Pet                            interface Flyer{
               -name, age                              abstract fly();
	       -abstract eat();                    }
   

    Cat extends Pet     Dog extends Pet                   
 @Override             @Override               
eat(){s.o.u("쩝쩝");}  eat(){s.o.u("냠냠");}    

    Bird extends Pet implments Flyer      Bat extends Pet  implments Flyer                ..   
 @Override                                @Override   
eat(){s.o.u("짹짹");}                      eat(){s.o.u("짹짹");}
@Override                                  @Override 
fly(){}                                   fly(){}

     목적2 (************************)
      - 클래스들간의 의존성 감소 ( loosly coupling (권장)  <----> tight coupling ) 

    예>
        main 클래스 -->  서비스 --->  OracleDAO클래스 --->  DB(오라클)
                       OracleDAO클래스
              
	                           MySQLDAO클래스 --->  DB(MySQL)



############################################################################
###### 참고할만한 사이트 소개 ##############################################
############################################################################
# 상속
 https://dev-gorany.tistory.com/147
# 상속관계와 포함관계
 https://back-end-developer.tistory.com/entry/JAVA-상속관계와-포함관계
# 상속의 개념
 http://www.tcpschool.com/java/java_inheritance_concept
# 상속/포함 등 클래스 간의 관계
 https://develaniper-devpage.tistory.com/75
# 상속 - 메소드 오버로딩과 오버라이딩의 차이…
 https://butter-shower.tistory.com/85
# 상속 + 메모리구조
 https://ksm0207.github.io/posts/increpasDay20/
 https://sehun-kim.github.io/sehun/extends/
# 자바 클래스의 상속(Extends) 사용법 & 예제
 https://coding-factory.tistory.com/865
# 메소드 재정의
 https://limesparkling.tistory.com/14
# 오버로딩과 오버라이딩
 https://software31.tistory.com/6
 https://wtg-study.tistory.com/18
# 자바 오버로딩과 오버라이딩 개념 완벽 정리
 https://lnsideout.tistory.com/entry/JAVA-자바-오버로딩과-오버라이딩-개념-완벽정리
# 어노테이션이 뭔데??
 https://velog.io/@jkijki12/annotation
# 어노테이션 정리
 https://steady-coding.tistory.com/614
# final 키워드
 https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=kiho0530&logNo=150143859108
# Java final
 https://shinny.tistory.com/42
# final과 static의 다양한 사용 방법
 https://ojava.tistory.com/50
# 단일 상속 & Object 클래스
 https://gyugyu.tistory.com/21
# 단일 상속
 https://build-enough.tistory.com/214
# 자바는 왜 다중 상속을 지원하지 않을까?
 https://nohriter.tistory.com/158
# Object 클래스
 https://dreaming5developer.tistory.com/78
# this와 this(), super와 super() 차이점
 https://velog.io/@vgo_dongv/Java-this와-this-super와-super-차이점
 https://qh5944.tistory.com/176
# 다형성의 개념
 http://www.tcpschool.com/java/java_polymorphism_concept
# 다형성이란?
 https://dev-cini.tistory.com/60
# 다형성의 이해 및 예제
 https://kadosholy.tistory.com/99
# 자바 다형성 기본 및 활용
 https://life-with-coding.tistory.com/485#google_vignette
#자바의 다형성 완벽 이해하기
 https://inpa.tistory.com/entry/OOP-JAVA의-다형성Polymorphism-완벽-이해
# instanceOf 연산자
 https://katfun.tistory.com/169
# 자바 toString 오버라이딩
 https://inpa.tistory.com/entry/JAVA-☕-toString-메서드-재정의-완벽-이해하기
# 추상클래스란?
 https://dev-cini.tistory.com/64
# 추상 클래스 용도 완벽 이해하기
 https://inpa.tistory.com/entry/JAVA-☕-추상-클래스Abstract-용도-완벽-이해하기
# 인터페이스 문법 & 활용
 https://inpa.tistory.com/entry/JAVA-☕-인터페이스Interface의-정석-탄탄하게-개념-정리
# 인터페이스 vs 추상클래스 용도 차이점
 https://inpa.tistory.com/entry/JAVA-☕-인터페이스-vs-추상클래스-차이점-완벽-이해하기ㄴ
# 자바 인터페이스 사용법& 예제
 https://coding-factory.tistory.com/867
# 클래스와 인터페이스
 https://brunch.co.kr/@oemilk/134
# 추상 클래스와 인터페이스 차이?
 https://velog.io/@mini_mouse_/추상클래스와-인터페이스의-차이
# 자바 일반 클래스와 추상 클래스의 상속 차이
 https://velog.io/@mini_mouse_/추상클래스와-인터페이스의-차이
# implements, extends 란?
 https://thenicesj.tistory.com/133
# 자바 다중상속 인터페이스 다루는 방법
 https://mainia.tistory.com/2139
# 인터페이스에서의 static 메소드와 default 메소드
 https://soft-dino.tistory.com/25
 https://yeon-kr.tistory.com/187
# 자바 8 인터페이스의 Default 메소드와 Static 메소드
 https://veneas.tistory.com/entry/Java-자바-8-인터페이스의-Default-메소드와-Static-메소드#google_vignette

############################################################################
중첩클래스 ( 익명클래스)
예외처리
유틸리티 (Random, .............. )
제네릭스
컬렉션
람다 및  스트림
추가과정: java i/o, thread , network

############################################################################
9일차 리뷰

1. 개발자가 작성하는 최소 단위

   가. 클래스 ( 변수, 메서드 )
     - 현실세계의 객체 ( 속성, 동작 )
     - 구성요소
       변수(멤버변수, 인스턴스변수) : 속성의 값을 저장
       메서드(멤버메서드, 인스턴스메서드): 변수의 값을 수정,조회,체크,...
       생성자(멤버포함안됨): 변수 초기화
     - 사용?  반드시 heap메모리에 로딩(loading)해야 되고
             객체생성(new) 이용해서 로딩된다. ( loader )
	     클래스 변수명 =  new 클래스();
	     변수명.멤버변수;
	     변수명.멤버메서드();

   나. 상속(inheritance) => 같은 종류의 클래스가 여러개가 작성된 상황인 경우

      예> Cat, Dog, Bird, Bat,...

         공통적인 속성: 이름,성별,..     =======> 새로운 클래스 지정, 하위클래스 모두 포함가능한 타입.
	 공통적인 동작: 먹기, 자기,...

	 Object (최상위 클래스, root 클래스)  
	  |
	 Pet
	  |  (삼각형 실선), extends Pet
    Cat  Dot  Bird Bat ,...

    - 모든 클래스(사용자지정클래스, API)는 상속관계로 되어 있다. ==> 계층구조를 갖는다.
    - 상속 불가 요소 2가지 ( 부모의 생성자, private 된 멤버 )
    - 오버라이딩이 가능 ( 상속전제, 부모의 메서드를 자식이 재정의 )
      규칙: 부모의 리턴타입,변수명,인자리스트는 반드시 동일.
           접근지정자는 같거나 덜 엄격한 레벨로 지정가능.
	   예외클래스는 같거나 자식 클래스 레벨로 지정가능.
      @Override 어노테이션을 지정해서 정보지정 및 규칙위반시 컴파일 에러를 발생시킴.
    - 항상 자신보다 부모를 먼저 생성한다. ( 자식 생성자 첫라인에서 항상 부모 생성자를 호출하는 코드가 삽입: super() )
    - 단일 상속
  
  다. 추상 클래스 ( abstract class )
    -목적: 부모가 가진 임의의 메서드를 자식들이 사용하도록 강제하고자 할때이다.
          오버라이딩은 강제성이 없기 때문에 불가능하다.
 
    - 문법: 
          public abstract class 클래스{
               
	       변수
	       메서드
	       생성자

	       추상 메서드(abstract method): {} 지정안함. 불완전 메서드
	  }

    - 특징: -객체생성불가
           -추상클래스 자신은 인스턴스가 불가능하지만 다른 클래스를 이용하면 
	   추상클래스를 인스턴스화가 가능하다.

	   추상클래스 ( 큰타입)
	      | (삼각형 실선, 상속관계), extends 
	   다른클래스 ( 작은타입)

           -추상클래스의 추상메서드를 하위 클래스가  반드시 재정의해야 되는 강제성이 부여된다. (*********)
	   따라서 추상클래스를 상속받은 모든 하위클래스들의 메서드를 일치시키게 할 수 있다. 
           - 다형성 적용 가능
	    예> 추상클래스  변수 = new 하위클래스();

  라. 인터페이스 (interface )
    -목적: 특정 메서드를 자식들이 사용하도록 강제하고자 할때이다.
    -문법:
         public interface 인터페이스{

               상수: public static final 자동지정
	       default메서드:  public default void a(){}
	       static메서드: public static void b(){}

	       추상 메서드(abstract method): {} 지정안함. 불완전 메서드

	 }

    - 특징: -객체생성불가
           -인터페이스 자신은 인스턴스가 불가능하지만 다른 클래스를 이용하면 
	   인터페이스를 인스턴스화가 가능하다.


       인터페이스   인터페이스
             |     |  ( 삼각형 실선, 상속관계, extends , 다중상속 )
             인터페이스


      인터페이스1    인터페이스2 (큰 타입 )
	      | (삼각형 점선, 구현관계), implements , 다중구현
	      |
	   다른클래스 ( 작은타입)

	- 인터페이스의 추상메서드를 하위 클래스가  반드시 재정의해야 되는 강제성이 부여된다. (*********)
	   따라서 인터페이스를 구현한 모든 하위클래스들의 메서드를 일치시키게 할 수 있다. 

	- 다형성 적용 가능
	    예> 인터페이스  변수 = new 하위클래스();


클래스                        추상 클래스                    인터페이스
-----                      ----------                   -----------
목적: 현실세계의 객체표현      목적: 클래스의 특정메서드를          목적: 특정 메서드를 하위에서 사용하도록 강제.
                            자식이 사용하도록 강제.
구성요소:변수,메서드,생성자    구성요소: 변수,메서드,생성자,        구성요소: 상수, default메서드, static메서드,
                                추상메서드                       추상메서드

특징: new 가능(인스턴스화가능) 특징: new 불가                  특징: new 불가
    상속관계(단일상속)            상속관계(단일상속)                 구현관계(다중구현), implements
    다형성 가능                  다형성 가능                      다형성 가능
    하위클래스에서 부모메서드의      하위클래스에서 반드시               하위클래스에서 반드시
    대한 강제성이 없음	      추상메서드를 재정의해야됨.           추상메서드를 재정의해야됨.
			      (강제성)                         (강제성)
			                                     인터페이스간에는 다중상속이 가능.

###################################################################
10일차 ( 3월 21 일 )

1. 중첩 클래스 ( nested class, inner class )
 
 1) 개념:  클래스내에 또 다른 클래스를 지정할 수 있고
          클래스내에 있는 클래스를 중첩클래스라고 한다.

    형태:
            public class 클래스{  // Outer 클래스
	       static int n = 10; //가능
	     private int n2 = 10;
               int n3 =20;

		class 클래스{   // 중첩클래스( inner 클래스 )
                  static int n2 = 20; // 불가능
		  sysout(n2 + n3)// private으로  된 변수도 사용 가능
		}
	 static class 클래스{
                 static int n2 = 20; // 가능
                 sysout(n2);// outer클래스의 인스턴스 변수 사용불가
		 sysout(n3);// outer클래스의 인스턴스 변수 사용불가
		}

	    }
       
	
 2) 특징: - static변수 사용 불가.
           단 static으로 지정한 중첩클래스는 사용 가능
	   static으로 지정된 중첩클래스는 outer의 인스턴스변수 접근불가
         - 반드시 Outer 생성후 Inner 생성이 가능하다.
	  ==> 다른 클래스가 사용할려면 복잡하다. 따라서 다른 클래스는 사용을 안하고
	      Outer만 일반적으로 사용한다.
	 - inner 클래스 컴파일된 파일명:  Outer클래스명$Inner클래스명.class 

 3) 종류 : 중첩클래스가 outer클래스내의 어떤 위치에 정의되었냐?

         class Outer{

             int n; //멤버변수
	     public void a(){ //멤버메서드
                int x = 10; //로컬변수
                class Inner3{ // Local Inner class

		}
	     }
	     class Inner{  //  Member Inner class ( 일반적으로 불리우는 중첩클래스 )

	     }
  
         static class Inner2{  //  Static Inner class

	    }

             public Outer(){}
	 }//end Outer


2. 익명 클래스 ( annoymous class, 이름없은 클래스 ) ==> 람다표현식(lambda) 

  1) 중첩클래스 범주에 속함
  2) 용도: 인터페이스 (interface) 사용할 때 익명클래스를 적용할 수 있다.
  3) 문법:

       예>   public interface Flyer{
                public abstract void fly();
             }
        // 1. 일반적인 방법 ( 이름있는 클래스 이용 )
             가. 하위클래스 작성
	        public class Bird implements Flyer{
                    @Override
		    public void fly(){}
		}

             나. 하위클래스 객체생성
	        Bird b = new Bird();
		b.fly();
		//다형성 적용
		Flyer b2 = new Bird();
		b2.fly();


	// 2. 익명 클래스 ( 이름없는 클래스 이용 )

	  문법:  인터페이스명   변수명 =  new 인터페이스명(){

			 //추상메서드 재정의
	        };
		변수명.메서드();
	
	     예>  Flyer f = new Flyer(){
		    @Override
		    public void fly(){
		        
		    }
	         };
		 f.fly();
	         

3. 람다표현식 (  lambda expression )

 1) 용도: 익명클래스의 축소된 표현식이다.
 2) 등장배경: '기능(메서드의 기능)에만 집중하자' ==> 함수형 프로그래밍(functional programming)

                 Flyer f = new Flyer(){
		    @Override
		    public void fly(){
		        //기능
		    }
	         };
		 f.fly();

 3) 메서드가 4가지 형식이기 때문에 람다표현식도 4가지 표현식이 가능.
     가. 파라미터없고 리턴값없는 형태
     나. 파라미터있고 리턴값없는 형태
     다. 파라미터없고 리턴값있는 형태
     라. 파라미터있고 리턴값있는 형태

 4) 단일책임원칙 개발방법론
 ==> 개념은 하나의 객체에 하나의 기능만 추가해서 명확한 책임을 부여하자.
 ==> 람다표현식에서 사용하는 인터페이스가 가진 메서드는 반드시 1개만 가능.

      @FunctionalInterface  ==> 추상메서드가 반드시 1개만 지정하도록 강제
      public interface Flyer{
         public abstract void fly();
      }

 * 순서
 1. 인터페이스 정리
 2. 익명클래스 정리
 ==> 함수형 프로그래밍
 3. 람다 표현식
 4. 함수형 인터페이스
   ==> 실습에서 만든 파라미터(없고)있고 리턴값(없고)있고 형식의 
      추상메서드를 가진 인터페이스를 API로 제공된다.

   ==> Function 인터페이스
       Consumer 인터페이스
       Predicate 인터페이스
       Operator 인터페이스
       Supplier 인터페이스

 5. 컬렉션의 스트림 문법.

############################################################################
###### 참고할만한 사이트 소개 ##############################################
############################################################################

# 구상 클래스(Concrete class)란?
 https://kangworld.tistory.com/240
# 추상클래스, 구상클래스, 인터페이스
 https://velog.io/@yongseok0419/추상클래스-Abstract-Class-구상클래스-Concrete-Class-인터페이스-Interface
# Coupling이란? Tight Coupling vs Loose Coupling 정리
 https://swk3169.tistory.com/185
# 객체지향 프로그래밍과 설계
 https://getchan.github.io/cs/oop_interface_2/
# 익명 클래스
 https://sgcomputer.tistory.com/82
# 익명 클래스 사용법 총정리
 https://inpa.tistory.com/entry/JAVA-☕-익명-클래스Anonymous-Class-사용법-마스터하기
# 무명 클래스와 익명 구현 객체
 https://movefast.tistory.com/34
# 내부 클래스와 익명 클래스
 https://pridiot.tistory.com/52
# 익명클래스와 람다
https://www.codelatte.io/courses/java_programming_basic/O2PZAC2T82LKBXAY

############################################################################
############################################################################
유틸리티
예외처리
제네릭스
컬렉션
Stream

################################################################
10 일차 리뷰

1. 자바기반의 *.java 로 만들 수 있는 것

  1) 일반 클래스 ( concrete class )
    - 변수 : 데이터 저장
    - 메서드: 변수의 관리( 수정,조회,검증)
    - 생성자 : 변수 초기화
    특징: new 필수

  2) 추상 클래스 ( abstract class )
    - 변수 : 데이터 저장
    - 메서드: 변수의 관리( 수정,조회,검증)
    - 생성자 : 변수 초기화
    - 추상메서드(abstract method)
      => public abstract void a();
      => 하위클래스에서 추상메서드명으로 사용하도록 강제할 목적.

    특징: 불완전 클래스이기 때문에 new 불가. ( 인스턴스화 불가 )
         추상클래스를 상속받은 하위클래스 이용해서 추상클래스의 구성요소가
	 인스턴스화 될 수 있다.
	 반드시 추상클래스의 추상메서드를 재정의해야되는 제약이 부여된다. ( 재사용성 )
 
   3) 중첩 클래스 ( nested class )
    
     개념: 클래스(outer)내의 클래스(inner,nested)가 선언된 경우.
     문법:
          class Outer{  ==> Outer.class 컴파일 됨.
              private int n = 10;
	      class Inner{ ==> Outer$Inner.class 컴파일 됨.
		 
 
	      }
	  }

     종류: 
       - Member Inner Class (***)
       - Local Inner Class
       - Static Inner Class
       - Anonymous Inner Class (*****)

     특징: - static 변수 선언이 불가. 
              ==> static inner class로 지정하면 static 변수사용가능.
	         하지만 Outer의 멤버를 접근불가
          - private로 된 Outer의 멤버를 접근가능.
	  - 직접 Inner 접근을 불가. 반드시 Outer를 통해서 Inner를 접근할 수 있다.
	    따라서 일반적으로 외부클래스에서는 Inner를 사용안하고 Outer 가 사용한다.
	  - 중첩클래스는 안드로이드 개발코드에서 거의 대부분 사용된다.(********)


   4) 인터페이스 (interface )
    
     1)문법:
         public interface 인터페이스{

	 }

     2) 구성요소
       - 상수: public static final 자동지정
       - default 메서드: public default void a(){}
       - static 메서드: public static void b(){}
       - 추상 메서드:  public abstract 자동지정
             
	     public abstract void c();
	     public void c2();
	     void c3();

     3) 특징: 불완전객체이기 때문에 new 불가.
            구현관계인 하위클래스를 이용해서 인스턴스화 된다.
            반드시 추상메서드를 재정의해야되는 제약이 부여된다. (**********)


           인터페이스
              | (상속관계, extends,  다중상속)
	    인터페이스
              |
	      | (구현관계, implments, 다중구현)
	    클래스

      4) 설계입장에서 interface 사용된다. (*********************************)
         ==> 의존성 감소 (loosely coupling )


2. 익명클래스

 1) 용도: 인터페이스를 사용할 때 명시적인 클래스없이 사용하는 방법.
 2) 문법:
          인터페이스  변수 =  new 인터페이스(){
                 //추상메서드 재정의
	  };

	예> Flyer f = new Flyer(){
               @Override
	       public void fly(){}
	   };
           f.fly();

3. 람다표현식 (lambda expression)
 1)용도: 익명클래스 표현방법을 축소된 표현식이다. ( 함수형 프로그래밍에 기반이 된다. )
 2)4가지 표현식
     - 파라미터없고 리턴값 없는 경우
     - 파라미터없고 리턴값 있는 경우
     - 파라미터있고 리턴값 없는 경우
     - 파라미터있고 리턴값 있는 경우

 3) 특징: 나중에 함수형 인터페이스( 자바에서 제공하는 인터페이스 의미) 확장되고
         컬렉션의 스트림(stream)기능으로 더 확장된다.
#########################################################################
11일차
0. final ( 마지막 )
  변수에 final 사용: 상수 (값 수정 불가 )
  메서드에 final 및 static 사용: 오버라이딩(overriding) 불가. 
  클래스에 final 사용: 상속불가

1. 유틸리티 클래스 ( API )

 1) java.lang.String 클래스

    가. 사용방법 2가지 
      - 리터럴 이용 ( ****** )
          String s = "hello";
          String ss = "hello"; 
        ==> 동일한 문자열은 한번만 생성됨.
	    s==ss 일때 true 반환됨.

      - new 이용
          String s2 = new String("hello");
          String ss2 = new String("hello");
        ==> new 할때마다 매번 생성됨.
	    s2==ss2 일때 false 반환됨.
        중요: 문자열 값을 비교할 때는 반드시  equals 메서드를 사용해야 된다.

    나. 메서드 정리
        	//1. 생성
		String s = "helLO";
		String s2 = "     helLO     ";
		
		//2. 인스턴스 메서드 ( s.메서드 형식 )
		int n = s.length();
		System.out.println("1. 문자열길이: " + n);   // 5

		char c = s.charAt(0);
		System.out.println("2. 특정문자조회: " + c);   // h
		System.out.println("3. 부분열: " + s.substring(1));   // elLO
		System.out.println("3. 부분열: " + s.substring(1, 4));   // elL, endIndex는 항상 전까지
		
		System.out.println("4. 특정문자위치: " + s.indexOf("e"));   // 1
		System.out.println("4. 특정문자위치: " + s.indexOf("E"));   // -1 (일치하는 문자가 없으면 -1 반환 )
		
		System.out.println("5. 대문자: " + s.toUpperCase());   // HELLO
		System.out.println("6. 소문자: " + s.toLowerCase());   // hello
		
		System.out.println("7. 문자열 값비교: " + s.equals("helLO"));   // true
		System.out.println("7. 문자열 값비교: " + s.equals("hello"));   // false ( equals는 대소문자 구별)
		System.out.println("7. 문자열 값비교(대소문자무시): " + s.equalsIgnoreCase("hello"));   // true
		
		System.out.println("8. 문자열 포함여부: " + s.contains("el"));   // true
		System.out.println("8. 문자열 포함여부: " + s.contains("xe"));   // false
		
		System.out.println("9. 문자열 치환: " + s.replace("h", "H")) ;   // HelLO
System.out.println("원본문자열: " + s);  // String 는 한번 생성하면 변경 안됨. 메서드를 적용하면 새로운 문자열이 생성됨.
		
		String x = s2.trim();		
		System.out.println("10. 공백제거 전: " + s2) ;   //      hello     
		System.out.println("10. 공백제거 전  길이: " + s2.length()) ;   // 15   
		System.out.println("10. 공백제거 후: " + x) ;   // hello
		System.out.println("10. 공백제거 후 길이:" + x.length()) ;   // 5
		System.out.println("10. 공백제거 후 길이(메서드체인):" + s2.trim().length()) ;   // 5
		
		System.out.println("11. 문자열 연결: " + s.concat("!!!")) ;  // helLO!!!
		
		char [] chr = s.toCharArray();
		System.out.println("12. 문자열을 char [] 반환: " + Arrays.toString(chr)) ;  // [h, e, l, L, O]
		
		String x2 = "홍길동/이순신/유관순"; // 홍길동,이순신,유관순
		String [] x3 = x2.split("/");
		System.out.println("13. 구분자로 분리해서 배열로 반환: " + Arrays.toString(x3)) ;  // [홍길동, 이순신, 유관순]
		
		//3. static 메서드 ( String.메서드 형식 )
	    // "10" ---> 10
		 int k = Integer.parseInt("10");
		 System.out.println(k+20);
		
		// 비문자열 ---> 문자열
		String x4 = String.valueOf(true);
		String x5 = String.valueOf(100);
		String x6 = String.valueOf(3.14);
		String x7 = String.valueOf(new char[] {'A','B','C'});


    다. 특징
       - String 는 한번 생성하면 변경 안됨. 메서드를 적용하면 새로운 문자열이 생성됨.
         문자열 값을 변경하는 작업이 빈번하다면 String 사용은 지양해야 된다.

 2) java.lang.StringBuilder 클래스


    가. 사용방법 1
        
	StringBuilder sb = new StringBuilder("hello");

    나. 메서드 ( 특징: append, insert, delete, reverse )
         	// 1. 생성
		StringBuilder sb = new StringBuilder("hello");
		
		// 2. 메서드
		System.out.println("1. 값출력: " + sb); // sb.toString() 동일
		
		
		System.out.println("2. 값 추가: " + sb.append(true)); //  hellotrue
		System.out.println("2. 값 추가: " + sb.append(100)); // hellotrue100
		System.out.println("2. 값 추가: " + sb.append(3.14)); // hellotrue1003.14
		System.out.println("2. 값 추가: " + sb.append("world")); // hellotrue1003.14world
		System.out.println("2. 값 추가: " + sb.append(new char[] {'A','B'})); // hellotrue1003.14worldAB
		
		System.out.println("3. 값 삽입: " + sb.insert(0, "홍길동")); //홍길동hellotrue1003.14worldAB 

		System.out.println("4. 값 삭제: " + sb.delete(0, 3)); //hellotrue1003.14worldAB 
		System.out.println("4. 값 삭제: " + sb.deleteCharAt(0)); //ellotrue1003.14worldAB 
		
		System.out.println("5. 값 거꾸로: " + sb.reverse()); //BAdlrow41.3001eurtolle
		
		//String에서도 제공되었던 메서드
		System.out.println("6. 길이: " + sb.length()); // 22
		System.out.println("7. 특정문자얻기: " + sb.charAt(0)); // B
		System.out.println("8. 특정문자 위치얻기: " + sb.indexOf("w")); // 6
		System.out.println("9. 부분열: " + sb.substring(6)); // w41.3001eurtolle
		System.out.println("9. 부분열: " + sb.substring(6,7)); // w
		
		// StringBuilder --> String
		String xxx = sb.toString();
		System.out.println(xxx);

    다. 특징
     -  StringBuilder 는 한번 생성하면 변경도 가능하다. ( 버퍼 기능 )
        문자열 값을 변경하는 작업이 빈번하다면 StringBuilder 사용을 지향해야 된다.



  3) wrapper 클래스

    개념: 기본형 8개에 해당하는 참조형인 클래스를 묶어서 부르는 이름이다.

       기본형              참조형(클래스)
       ----              ----
       byte		Byte
       short		Short
       int		Integer
       long		Long

       float		Float
       double		Double

       char		Character

       boolean		Boolean

    제공이유:  wrapper 클래스내의 상수 및 메서드의 도움을 받을 수 있다.
    특징: 거의 대부분의 멤버가 static로 되어있다. ( new 없이 매우 손쉽게 사용할 수가 있다. )

    추가개념: 오토박싱(auto boxing), 오토언박싱(auto unboxing)

   4) 날짜 데이터
   
     가. java.util.Calender
        - Date 보다 나중에 지원
	- new 방법으로 생성하지 않고 메서드를 이용해서 인스턴스를 얻는다.

	    Calendar cal = Calendar.getInstance(); // getInstance() 안에서 new 하고 리턴해줌.
            int year = cal.get(Calendar.YEAR);

     나. java.util.Date
        - 초창기 지원
	- 대부분이 deprecated 됨.
	- 생성방법
	   Date d = new Date();
	   sysout(d);  // Fri Mar 22 14:45:08 KST 2024

	- 유틸리티 클래스인 java.text.SimpleDateFormat 이용해서 개별적인 날짜정보를 얻을 수 있음.

	예>  import java.util.Date;
	    import java.text.SimpleDateFormat;

	    Date d = new Date(); // Fri Mar 22 14:45:08 KST 2024

            SimpleDateFormat sdf = new SimpleDateFormat("yyyy");  // "패턴" 지정
	    String year = sdf.format(d);

	 
   5) java.util.StringTokenizer

     ==> String 클래스의 split("/") 기능보다 업그레이드된 클래스.
 
       예> //2. java.util.StringTokenizer 이용
		StringTokenizer st = new StringTokenizer(s, ",");
		System.out.println("token 갯수: " + st.countTokens());
		
		while(st.hasMoreTokens()) {
			System.out.println("token 얻기: " + st.nextToken());			
		}
		
		// 구분자가 여러개인 경우에도 잘 분리해준다.
		String x = "홍|길동,이순|신,유관순/AAA/BBB";
		StringTokenizer st2 = new StringTokenizer(x, "/,|");
		while(st2.hasMoreTokens()) {
			System.out.println("token 얻기2: " + st2.nextToken());			
		}

   6)  enum 타입
    
     ==> 개별적으로 사용되는 여러개의 상수를 효율적으로 사용가능한 객체이다.
     ==> 문법:
      
         public enum  enum명{
              상수명, 상수명2, ...;
	 }

        - enum명.상수명 형식으로 사용
        - 상수값은 알려진 값이 대부분 예> 요일, 월, 계절, 학년
	
    ==>  switch문에서 주로 사용됨.

  
   7) java.util.Arrays

    ==> 배열관련 유틸리티 클래스
    ==> 배열 자체에는 메서드가 없고 단지 lenght 속성만 제공된다.

    
		//1. 오름차순 정렬 ( Arrays.sort() )
		int [] arr = {6,2,1,85,23};
		Arrays.sort(arr); // 내림차순 정렬: sort(배열, Comparator인터페이스구현)
		System.out.println("1. 정렬:" + Arrays.toString(arr) );  // [1, 2, 6, 23, 85]
		
        
		//2. 배열값 출력 ( Arrays.toString() , **************** )
		int [] arr2 = {6,2,1,85,23};
		System.out.println("2. 배열값 문자열로 한꺼번에 출력:" + Arrays.toString(arr) );  // [1, 2, 6, 23, 85]
		
		//3. 여러개의 값들을 --> 컬렉션의 List, **************** )
		List<Integer> list = Arrays.asList(10,20,30);
		System.out.println("3. 여러 값들을 List 컬렉션으로 변경:" + Arrays.asList(10,20,30) );  // [10, 20, 30]
		
		//4. 전체 배열값 채우기
		int [] arr3 = {6,2,1,85,23};
		Arrays.fill(arr3, 100);
		System.out.println("4. 값 채우기:" + Arrays.toString(arr3) );  //[100, 100, 100, 100, 100]
		
		//5. 특정 범위 배열값 채우기
		int [] arr4 = {6,2,1,85,23};
		Arrays.fill(arr4, 0,3,100); // fill(배열, start, end, 변경값)
		System.out.println("5. 특정 범위 배열값 채우기:" + Arrays.toString(arr4) );  //[100, 100, 100, 85, 23]
		
		//6. 배열값 비교
		int [] arr6 = {6,2,1,85,23};
		int [] arr7 = {6,2,1,85,23};
		System.out.println("6. 배열값 비교" + Arrays.equals(arr6, arr7) );  // true
		
		//7. 배열에서 특정값의 위치얻기
		int [] arr8 = {6,2,1,85,23};
		System.out.println("7. 배열에서 특정값의 위치얻기" + Arrays.binarySearch(arr8, 85) );  // 3
	
		
		//8. 배열복사 및 크기변경
		int [] arr9 = {6,2,1};
		int [] arr10 =Arrays.copyOf(arr9, 5);
		System.out.println("8. 배열복사 및 크기변경:" + Arrays.toString(arr10) );  //
###################################################################################
#########################################################################
- 예외처리
- 제네릭스
- 컬렉션
- 람다
- 함수형 인터페이스
- 스트림(stream)

추가: java I/O, 스레드, 네트워크
##########################################################################
12일차
1. 예외처리 ( exception handling )
 
  1) 예외(exception)?
   - 일반적으로 에러(error)라고 불리우는 사건이다.
   - 예외가 발생되면 프로그램이 '비정상 종료' 된다.

  2) 예외처리(exception handling)?
   - 예외가 발생되면 '비정상종료' 되는데,
     비정상 종료되는 프로그램을 '정상 종료'하도록 처리하는 방법이다.
   - 정상종료 처리방법은 사용자에게 문제발생 이유를 알려주는 방법(콘솔 또는 경고창)도 포함됨.
     사용자가 이해하기 쉽도록 친절하게 알려줘야 된다. ( 예> 한국어 )
   - 잘못 알고 있는 경우는 문제발생된 상황을 해결해주는 것이 아니다. ( 불가능 함)
     문제발생된 코드는 어쩔수 없이 실행이 안되고 이후의 코드를 실행해서 
     main 끝(정상종료)까지 가도록 하는 작업이 개발자가 해야되는 예외처리이다.

   3) 예외처리 방법

    가. 예외 클래스 제공
        
	   Object
	      |
	   Throwable
	      |
   Error                       Exception ( 예외처리시 사용하는 예외클래스의 최상위 )
-개발자가 핸들링 불가                   |
                  
	     RuntimeException                        IOException,SQLException  
	     (런타임 계열: 런타임시(실행)발생,)                   ( 비런타임 계열: 컴파일시 발생,
	      컴파일 unchecked 계열)                            컴파일 checked 계열
	      |                                           |
	                                             
	     ArithmeticException ( 예> 10/0 )         FileNotFoundException
	     ClassCastException ( 예> 클래스 형변환시 )       ...
	     NullPointerException ( 예> null값을 가진상태로
	                            메서드 호출시 )
	     ArrayIndexOutOfBoundsException (예> 없는배열요소
	                                      접근시 )

	      ... 

 
    나. 예외클래스 + try~catch~finaly 문
       - 예외가 발생된 곳에서 처리하는 방법이다.
       - 문법:
            try{
               실행문1; 
	       실행문2; 

	    }catch(예외클래스1 e){  // 적합한 예외클래스를 지정(권장), 다형성 가능(비권장)
               예외발생시 처리하는 문장;
	    }catch(예외클래스2 e){  // Exception 최상위 클래스는 반드시 가장 마지막에 지정한다.
	                            즉 계층구조의 자식부터 catch 해야 된다. ( 컴파일 에러 발생)
               예외발생시 처리하는 문장;
	    }finally{
               반드시 수행되는 문장; ( 파일 및 DB 연동시 close 작업 )
	    }
              문장;
              문장;
	}//end main

       - 예외관련 정보 제공
         e.printStackTrace(); ==> 자체적으로 print 가능, 예외발생메시지, 예외발생 line 정보, 예외클래스 정보등 제공함. 개발시 디버깅용으로 사용됨.
	 sysout( e.getMessage() ) ==> 예외발생메시지 제공.
   
      - try~finally문 가능 ( catch문 없이 사용 가능 )
        ==> 예외처리 목적이 아닌 반드시 실행해야 되는 문장을 알려주는 용도로 사용된다.
	  예>
	      try{

	      }finally{

	      }

    다. 예외클래스 + throws 예외클래스 문 ( 위임처리. ************* )
       - 예외가 발생된 곳이 아닌 다른 곳에서 위임 받아서 처리하는 방법이다.

       - 위임처리방법

       main(){               a(){                 b(){
                                                 //예외가 발생된 곳에서 예외처리
                                                  try{
         a();                 b();                  int n= 10/0; //ArithmeticException 발생
                                                  }catch(ArithmeticException e){

						  }
     sysout("정상종료");
       }                     }                    }
     ##########################################################   
	 
     main(){               a()throws Arithmet~{   b()throws ArithmeticException{
                                                 //예외가 발생된 곳에서 예외처리가 아닌 위임방식
						   ==> 메서드를 호출한 곳으로 위임한다.
      try{                                            
         a();                 b();                  int n= 10/0; //ArithmeticException 발생
      }catch(Ar~  e){
        e.printStackTrace();
      }
						  
     sysout("정상종료");
     }                     }                    }

   
    4) Overriding 관련 throws 처리

     부모: 
           public  void a() throws ArithmeticException{}
        

     자식: @Override
          public(확대) void a()  (축소){}  // 가능
	  @Override
          public(확대) void a() throws ArithmeticException (축소){}  // 가능

	  @Override
          public(확대) void a()throws RuntimeException (축소){}  // 불가능

	   @Override
          public(확대) void a()throws Exception (축소){}  // 불가능

	   @Override
          public(확대) void a()throws IOException (축소){}  // 불가능



 5) Runtime 계열의 특징

   - try~catch 또는 throws 방식으로 예외처리를 하는 것이 아니다.
    이유는 실제로는 실행할 때 예외가 발생되면 안되는 코드들이다.

   - 다음 런타임계열은  조건문으로 처리해야 된다.

      ArithmeticException ( 예> 10/0 )   
         예>
	     int n = 0;
if(n!=0)
	     int result = 10/n;

      ClassCastException ( 예> 클래스 형변환시 )      
         예>
	    Employee e = new Manager();

	    Manager m = (Manager)e;
if( e instanceof Cat)
	      Cat c = (Cat)e; // ClassCastException 발생

      NullPointerException ( 예> null값을 가진상태로 메서드 호출시 )
        예>
	   String name = null;
if(name!=null)
	   sysout(name.length()); // NullPointerException발생
     ArrayIndexOutOfBoundsException (예> 없는배열요소 접근시 )

  6)  비 런타임  계열의 특징
 
 - IOException, SQLException
 - 규칙: 반드시 try~catch 또는 throws 문을 이용해서 예외를 처리해야 된다. (**********)
       예외처리 안하면 컴파일 예외가 발생된다.

  결론은 I/O 작업 또는 DB 연동작업시 무조건 예외처리를 해야 된다. (***************)


  7) 명시적으로 예외를 발생시킬 수 있다. + 사용자정의 예외 클래스 작성

  - 용도: 시스템은 실행문장을 예외로 처리하지 않는 정상적인 코드로 인식하기 때문이다.
       그런데 사용자는 문제있는 코드로 인식 할 수 있다.

    예> Random 클래스에서 랜덤값이 0일 때

  - 문법:

         if(n == 0) throw new MyException("예외메시지");
  
  - throw vs throws

    throw: 명시적으로 예외 발생할 때
    throws: 위임할때


  - 사용자정의 예외 클래스 작성 방법
   
    public class MyException extends Exception{
	// 문자열 하나 저장가능한 생성자만 있으면 됨. 필요시 추가로 변수, 메서드 지정 가능.
	public MyException(String mesg){
	   super(mesg);
	}
    }

#################################################################
2. 제네릭스 ( generics )

 1) 개념
  다양한 타입을 다루는 메서드 및 클래스(컬렉션)에서  
  컴파일시점(*)에 타입체크를 해서 예외를 미리 알 수 있도록 지원가능.

 2) 장점 2가지
   - 저장하는 객체의 타입 안전성 확보 ( 저장하고자 하는 데이터형을 제한 할 수 있다. ) 
   - 형변환 번거로움을 제거할 수 있다.

 3) 제네릭스 표현 ( 타입 파라미터 라고 부른다. )
  <T>: reference Type 의미
  <E>: Element 의미
  <K,V>:  Key, Value 의미

 4) 특징
   - <T> 같은 제네릭은 컴파일 시점에 실제 지정된 타입으로 치환됨.
   예> <T> --> <String>
   - 타입 파라미터는 인스턴스 멤버로 간주한다.
     static 사용불가, 객체생성불가, instanceof 사용 불가
   - 클래스 및 인터페이스, 메서드 파라미터로 사용 가능.

 5) 메서드 파라미터 전달시 사용되는 파라미터 타입 표현식
    - method(List<?> xxx) ==> 제네릭된 모든 데이터타입 전달 가능
    - method(List<? extends Person> xxx) ==> 제네릭된 Person 또는 Person의 자식 데이터타입만 전달 가능
    - method(List<? super Man> xxx) ==> 제네릭된 Man 또는 Man의 부모 데이터타입만 전달 가능

3. 컬렉션 API

 1) 데이터 저장 방법
   가. 변수

   나. 배열
     - 크기 변경 불가
     - 같은 데이터타입만 저장 가능
     - 지원되는 메서드가 없다.
       나중에 추가된 API가 Arrays 유틸리티 클래스이다.

   다. 컬렉션 API
     - 크기 변경 가능 
     - 저장하는 데이터 타입에 제한이 없다.
     - 지원되는 메서드가 많다.
       추가된 API가 Collections 유틸리티 클래스이다.
  
 2) 컬렉션 API 종류 ( java.util 패키지 )
            Box<T>
            Collection<E> (인터페이스)                Map<K,V> (인터페이스)
                 | (상속)                               |
  Set<E>(인터페이스)          List<E>(인터페이스)                 | (구현)
      |                    |                        HashMap<K,V>(*)
      | (구현)              | ( 구현 )  
   HashSet<E>(*)             ArrayList<E>(*)


   * 데이터 저장 방식에 따른 3가지 저유
   가. set계열: 저장되는 데이터의 순서가 없음.
              중복저장이 안됨.(한 번만 저장됨 )

   나. list계열: 저장되는 데이터의 순서가 있음.
                중복저장이 가능.

   다. map계열 : 데이터뿐만 아니라 데이터의 이름(키)까지 같이 저장됨.
                ( key/value 쌍으로 저장됨 )
		저장순서가 없다.
		key 이용해서 value 얻음.


###############################################33
12일차 리뷰
1. 예외처리
  1)예외발생된 경우 상황? 비정상종료
  2)예외처리? 비정상종료--> 정상종료.
            예외의 원인인 코드수정은 불가.
  3)방법?
    - 예외클래스 계층구조
               
	       Object
	          |
	       Throwable
	          |
	      Exception (예외클래스 최상위 간주)
	        |
   RuntimeExcetion                    IOException,SQLException
   (런타임계열, 컴파일 unchecked계열)       ( 비런타임계열, 컴파일 checked 계열)
    |                                      |
   NullPointerException                FileNotFoundException
   ArithmeticException
   ArrayIndexOutofBoundsException
   ..
  => try~cacth 또는 throws 인          ==> 무조건 try~cacth 또는 throws 해야된다.(*****)
    예외처리로 문제 해결 안함.                 if 문으로 해결불가.
    if문 해결함.

   - 발생된 곳에서 처리
       try{
          실행문;
	  실행문;
       }catch(예외클래스 e){
         예외처리 코드
       }catch(예외클래스 e){
         예외처리 코드
       }finally{
         반드시 실행되는 코드
       }

   - 위임처리 (************)
     메서드 호출한 곳으로 위임하는 방식으로 main메서드까지 위임하고 마지막으로  main에서 try~catch로 처리한다.
     throws 예외클래스, 예외클래스{}

  4) 명시적으로 예외 발생시키는 방법

    if(조건식)throw new 예외클래스(메시지); // 메시지값은 e.getMessage()로 얻음.

  5) 명시적으로 예외 발생시킬때 사용하는 예외클래스를 사용자가 직접 만들어야 된다. ( 사용자 정의 예외클래스)

     public class MyException extends Exception{
         public MyException(String mesg){
             super(mesg);
	 }
     }

2. 제네릭스(generics)

  1) 표현식
    <T>
    <E>
    <K,V>
    <T,R>

  2) 특징
     - 관리하는 데이터의 타입을 명시적으로 지정한 타입으로 제한하는 방법
  3) 장점 2가지
     - 컴파일시에 잘못된 데이터가 저장된것을 확인이 가능하다.
     - 형변환 불필요

  4) 주요용도
    - 컬렉션 API
    - 함수형 인터페이스 및 stream API

###########################################################
13 일차

1. 제네릭스 ( generics )

 1) 개념
  다양한 타입을 다루는 메서드 및 클래스(컬렉션)에서  
  컴파일시점(*)에 타입체크를 해서 예외를 미리 알 수 있도록 지원가능.

 2) 장점 2가지
   - 저장하는 객체의 타입 안전성 확보 ( 저장하고자 하는 데이터형을 제한 할 수 있다. ) 
   - 형변환 번거로움을 제거할 수 있다.

 3) 제네릭스 표현 ( 타입 파라미터 라고 부른다. )
  <T>: reference Type 의미
  <E>: Element 의미
  <K,V>:  Key, Value 의미
  <T,R>:  Return type 의미

 4) 특징
   - <T> 같은 제네릭은 컴파일 시점에 실제 지정된 타입으로 치환됨.
   예> <T> --> <String>
   - 타입 파라미터는 인스턴스 멤버로 간주한다.
     static 사용불가, 객체생성불가, instanceof 사용 불가
   - 클래스 및 인터페이스, 메서드 파라미터로 사용 가능.

5) 메서드 파라미터 전달시 사용되는 파라미터 타입 표현식
    - method(List<?> xxx) ==> 제네릭된 모든 데이터타입 전달 가능
    - method(List<? extends Person> xxx) ==> 제네릭된 Person 또는 Person의 자식 데이터타입만 전달 가능
    - method(List<? super Man> xxx) ==> 제네릭된 Man 또는 Man의 부모 데이터타입만 전달 가능

2. 컬렉션 API

 1) 데이터 저장 방법
   가. 변수

   나. 배열
     - 크기 변경 불가
     - 같은 데이터타입만 저장 가능
     - 지원되는 메서드가 없다. 길이는 배열명.length 구한다.
       나중에 추가된 API가 Arrays 유틸리티 클래스이다.
     - Arrays 클래스의 메서드
       List xx = Arrays.asList(값,값2);
       Arrays.sort(값); //오름차순
       Arrays.fill(배열, 값);
       Arrays.copyOf()
       Arrays.equals(배열,배열2);
       ...

   다. 컬렉션 API
     - 크기 변경 가능 
     - 저장하는 데이터 타입에 제한이 없다.(일반적으로 제네릭스 사용해서 타입을 제한해서 사용한다. )
     - 자체적으로 지원되는 메서드가 많다.
       추가된 API가 Collections 유틸리티 클래스이다.
  
 2) 컬렉션 API 종류 ( java.util 패키지 )
            Box<T>
            Collection<E> (인터페이스)                Map<K,V> (인터페이스)
                 | (상속)                               |
  Set<E>(인터페이스)          List<E>(인터페이스)                 | (구현)
      |                    |                        HashMap<K,V>(*)
      | (구현)              | ( 구현 )  
   HashSet<E>(*)             ArrayList<E>(*)


   * 데이터 저장 방식에 따른 3가지 종류

   가. set계열: 저장되는 데이터의 순서가 없음.
               중복저장이 안됨.(한 번만 저장됨 )

   나. list계열: 저장되는 데이터의 순서가 있음.
                중복저장이 가능.

   다. map계열 : 데이터뿐만 아니라 데이터의 이름(키)까지 같이 저장됨.
                ( key/value 쌍으로 저장됨 )
		저장순서가 없다.
		key 이용해서 value 얻음.


  3) Collections 유틸리티 API
    - 컬렉션 정렬
      Collections.sort(리스트, Comparator타입);

   * Comparator는 인터페이스로서
     정렬할 변수 무엇인지 지정해야 될 의무가 있다.
     Comparator 내의 compare(T t1, T t2) 메서드를
     재정의해서 정렬할 변수를 구현한다.

    구현방법1: 익명클래스
            Comparator<Cat> comp = new Comparator<Cat>() {
			@Override
			public int compare(Cat c1, Cat c2) {
//				int result =c1.age - c2.age; // 오름차순. 
				int result =c2.age - c1.age; // 내림차순
				return result;  // result 가 0 이면 c1과 c2의 age가 같음.
				                // result 가 음수 이면 c1.age < c2.age 
				                 // result 가 양수 이면 c1.age > c2.age 
			}
        	
		};

    구현방법2: 람다 (*************)
    Comparator<Cat> comp2 = (c1 , c2)-> c2.age - c1.age;


3. 표준 API 함수적 인터페이스

   1) 개념
     - 메서드가 파라미터 및 리턴값의 존재여부에 따른 4가지 형태가 존재한다.
      * 4가지 표현식
     - 파라미터없고 리턴값 없는 경우
        예> public void method();

     - 파라미터없고 리턴값 있는 경우
         예> public int method();
            public String method();

     - 파라미터있고 리턴값 없는 경우
        예> public void method(int);
	   public void method(String);
	   public void method(int, String);

     - 파라미터있고 리턴값 있는 경우
       예> public int method(int);
	   public String method(String);
	   public int method(int, String);

  ==> 위 4가지 형식의 메서드를 가진 인터페이스를 API로 제공한다.
    따라서 위 기능이 필요할 때  직접 만들지 말고 API로 제공된 표준적 API 함수적 인터페이스를 사용하자.
    
   2) java.util.function 패키지
     ==> @FunctionalInterface 지정. 따라서 추상 메서드는 반드시 한개 존재함( 람다 표현식 사용 가능 )

     가. Consumer<T>
        - 추상메서드가 파라미터있고 리턴값은 없음.
	- void	accept​(T t)

       * BiConsumer<T,​U>: void	accept​(T t, U u)
         DoubleConsumer : void	accept​(double value)
         IntConsumer:     void	accept​(int value)
	 LongConsumer   : void	accept​(long value)
	 ObjDoubleConsumer<T>: void accept​(T t, double value)
	 ObjIntConsumer<T> : void	accept​(T t, int value)
	 ObjLongConsumer<T>: void	accept​(T t, long value)
 
    나. Supplier<T>
       - 추상메서드가 파라미터 없고 리턴값은 있음.
       - T get()

       * BooleanSupplier: boolean getAsBoolean()
         DoubleSupplier:  double getAsDouble()
	 IntSupplier :  int	getAsInt()
	 LongSupplier : long	getAsLong()

    다. Function<T,​R>
       - 추상메서드가 파라미터 있고 리턴값은 있음. ( 범용적 )
       - R apply​(T t)

       * BiFunction<T,​U,​R> : R	apply​(T t, U u)
         DoubleFunction<R> : R	apply​(double value)
	 DoubleToIntFunction: int applyAsInt​(double value)
	 DoubleToLongFunction : long	applyAsLong​(double value)
	 IntFunction<R> : R	apply​(int value)
	 IntToDoubleFunction : double	applyAsDouble​(int value)
	 IntToLongFunction: long	applyAsLong​(int value)
	 LongFunction<R>: R	apply​(long value)
	 LongToDoubleFunction : double	applyAsDouble​(long value)
	 LongToIntFunction : int	applyAsInt​(long value)
	 ToDoubleBiFunction<T,​U>: double	applyAsDouble​(T t, U u)
         ToIntFunction<T>     :  int applyAsInt​(T value)


    라. Operator
      - Function 처럼 파라미터 있고 리턴값은 있음.
      - Function API를 상속받음.
        특징은 전달되는 파라미터 타입하고 리턴값의 타입이 동일함.
        
	* BinaryOperator<T> : BiFunction의 하위 인터페이스이고 
	                      T apply(T t1, T t2)

	  DoubleBinaryOperator: double	applyAsDouble​(double left, double right)
	  DoubleUnaryOperator: double	applyAsDouble​(double operand)
	  IntBinaryOperator :  int	applyAsInt​(int left, int right)
	  IntUnaryOperator :   int	applyAsInt​(int operand)
	  LongBinaryOperator:  long	applyAsLong​(long left, long right)
	  LongUnaryOperator :  long	applyAsLong​(long operand)
	  UnaryOperator<T>:     T apply(T t)

    마. Predicate<T>
      - 추상메서드가 파라미터 있고 리턴값은 있음.
        리턴값은 boolean 값으로 제한됨.
      - 조건체크 용도
        논리연산자의 역할의 메서드 제공
	 && : and()
	 || : or()
	 !  : negate()
      - boolean	test​(T t)
      
 

      * BiPredicate<T,​U> : boolean	test​(T t, U u)
        DoublePredicate :  boolean	test​(double value)
	IntPredicate    :  boolean	test​(int value)
	LongPredicate   : boolean	test​(long value)



    3) Consumer, Function 같은 인터페이스는 여러 개 인터페이스를 순차적으로 설정
       - andThen()
      
      예>
       // 1. Consumer 순차적인 작업
	Consumer<String> c = t-> System.out.println("람다 Consumer1: " + t);
	Consumer<String> c2 = t-> System.out.println("람다 Consumer2: " + t);
	
	Consumer<String> c3 = c.andThen(c2);
	c3.accept("hello");
	
	//2. Function
	Function<String, Integer> f =  t->t.length();
	Function<Integer, Float> f2 =  t->t + 3.14F;
	
	Function<String, Float> f3 =    f.andThen(f2);
	System.out.println(f3.apply("hello"));


####################
1. 인터페이스
2. 익명클래스
3. 람다 ( 함수형 프로그래밍 )
4. 제네릭스
   <T>
   <E>
   <T,R>
   <T,U,R>
   <?>
   <? extends E>
   <? super E>

4. 표준 API 함수적 인터페이스
   Consumer<T> : 파라미터있고 리턴 없는 메서드 
   Supplier<R> : 파라미터없고 리턴 있는 메서드
   Function<T,R> : 파라미터있고 리턴있는 메서드 (*****)
                   파라미터 타입과 리턴타입이 같거나 다름. ( 타입제한이 없음)

   Operator      : Function 상속받음.
                   파라미터있고 리턴있는 메서드.
		   파라미터 타입과 리턴타입이 동일. ( 타입제한이 있음)

   Predicate     : 파라미터있고 리턴있는 메서드.
                   리턴타입은 반드시 boolean    ( 타입제한이 있음)
                   조건체크 용도로 사용되고 논리연산자 기능의 메서드가 제공됨.
		   and(), or(), negate()

   * 순차적으로 작업 가능
    andThen()


5. stream (*****)
########################################################################
14 일차

1. 메서드 참조(method reference)

  개념: 람다 표현식의 축약된 표현방법
  //1. static 메서드 사용:   문법: 클래스명::static메서드명
  //2. 인스턴스 메서드 사용 :    문법: 참조변수명::메서드명
                           단, 참조변수가 파라미터인 경우에는 클래스명::메서드명 형식사용.

  // 3. new 이용한 생성자 호출    문법: 클래스명::new
  // 4. sysout    문법: System.out::println
  

2. Stream API

 1) 용도:
    가. 이전 사용 형태
       컬렉션,배열,파일에서 읽어서 출력 및 간단한 작업(컬렉션에 값추가,삭제,수정)
       만약에 정렬기능, 필터기능, 가공기능이 필요하면 따로 구현해야 됨.

    나. Stream API 사용 형태
        컬렉션,배열,파일에서 Stream 타입을 얻으면,
        Stream 정렬기능, 필터기능, 가공기능,.... 내장이 되어있음.

     * 사용
      a. 컬렉션/배열/파일
      b. Stream 타입을 얻음.
      c. 중간처리
         - 정렬
	 - 가공
	 - 중복체거
	 - skip
	 ..
      d. 최종처리
         - 총합,평균,최대값,최소값, 갯수
	 - 컬렉션타입변경(List로 변경, Map변경,..)
	 - 반복출력

	 
2. 스트림 얻는 방법

  가. 컬렉션
     List<String> list = Arrays.asList("홍길동","이순신","유관순");
     Stream<String> s = list.stream();


  나. 배열
     String [] names = {"홍길동1","이순신1","유관순1"};
     Stream<String> s2 = Arrays.stream(names);	
     Stream<String> s3 = Stream.of(names);
     Stream<String> s4 = Stream.of("홍길동2","이순신2","유관순2");

3. 중간처리

  1) 중복제거:  distinct()
  2) 필터링 :  filter(Predicate)
  3) 가공   : map(Function), mapToInt​(ToIntFunction)
            ==> 한개 파라미터 입력되면 한개의 리턴값이 반환

	   : flatMap(Function) : Stream
	    ==> 한개 파라미터 입력되면 여러개가 하나에 저장되어 반환.
            // 하나의 파라미터로 복수개의 요소들로 구성된 새로운 Stream을 반환한다.
	    flatMap​(Function<? super T    ,​   ? extends Stream<? extends R>> mapper)
	     예> 입력: "a/b/c"
	        리턴: [a,b,c] 형태의 Stream 반환됨.

           : 반환값이 정수라면  flatMapToInt​(Function<? super T,​? extends IntStream> mapper)
 
   4) 정렬 : 
       a. 배열: Arrays.sort(배열);// 오름차순
               Arrays.sort(배열, Comparator);// 내림차순

       b. 컬렉션: Collections.sort(컬렉션, Comparator) // 오름차순,내림차순

       c. Stream: sorted()
                  sorted(Comparator)
		  sorted(Comparator.comparing(t->t.getEng())  // 권장, 기본은 오름차순
                  sorted(Comparator.comparing(t->t.getEng(), Comparator.reverseOrder())  // 내림차순

   5) 갯수 제한 및 skip
       
       - limit(n)
       - skip(n)

  =======> 중간처리는 처리후 거의 대부분이 Stream으로 반환됨.

4. 최종처리

  1) allMatch(Predicate) : 모든 값이 만족하는지 체크
     anyMatch(Predicate) : 최소 한개 값이 만족하는지 체크
     noneMatch(Predicate): 모두 만족 안하는지 체크

  2) 그룹핑 메서드
     - 합계: 	sum():int
     - 평균:     average():OptionalDouble ( Optional? 값이 있는 경우 반환된 값과 관련된 메서드 호출이 가능.
                                                     값이 없는 경우에는 기본값을 설정해서 메서드 호출이 가능하도록 처리)
     - 최대값: 	max(): OptionalInt
     - 최소값: 	min(): OptionalInt
     - 갯수: 	count(): long
    
   ==> Stream이 아니고 IntStream 인 경우에 사용할 수 있다. 단, count() 제외(******)
   ==> 중간처리와 연계해서 작업이 된다.
   
 3) 컬렉션 타입 변환
    - list로 변경
    - map로 변경
    예> .stream().collect(Collectors.toList());
       .stream().중간처리.collect(Collectors.toList()); // toMap(k,v)

 4) 컬렉션 대상의 그룹핑 메서드
    - collect(Collectors.counting());
    - collect(Collectors.summingInt(t->t.getEng()));
    - collect(Collectors.averagingDouble(t->t.getEng()));
    - collect(Collectors.maxBy(Comparator.comparing(Student8::getEng)));
    - collect(Collectors.minBy(Comparator.comparing(Student8::getEng)))